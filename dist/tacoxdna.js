!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("three")):"function"==typeof define&&define.amd?define(["three"],e):"object"==typeof exports?exports.tacoxdna=e(require("three")):t.tacoxdna=e(t.THREE)}(this,(function(t){return(()=>{"use strict";var e={807:e=>{e.exports=t}},s={};function n(t){var o=s[t];if(void 0!==o)return o.exports;var i=s[t]={exports:{}};return e[t](i,i.exports,n),i.exports}n.d=(t,e)=>{for(var s in e)n.o(e,s)&&!n.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var o={};return(()=>{n.r(o),n.d(o,{Logger:()=>l,convertFromTo:()=>T});var t=n(807);const e={0:"A",1:"G",2:"C",3:"T"},s={A:0,a:0,G:1,g:1,C:2,c:2,T:3,t:3,U:3,u:3,D:4};let i;try{i=Number.EPSILON}catch(t){i=2220446049250313e-31}const a=.4+.2,r=.3897628551303122;class l{static log(t,e=l.INFO,s){void 0===e&&(e=l.INFO),e<l.debug_level||(null!=s&&l.debug_level===l.DEBUG?l.logFunction(`${l.messages[e]}: ${t} (additional info: '${s}')`):l.logFunction(`${l.messages[e]}: ${t}`))}static die(t){throw l.log(t,l.CRITICAL),t}}l.DEBUG=0,l.INFO=1,l.WARNING=2,l.CRITICAL=3,l.debug_level=l.INFO,l.messages=["DEBUG","INFO","WARNING","CRITICAL"],l.logFunction=console.log;class c{constructor(e,n,o,i,a=new t.Vector3(0,0,0),r=new t.Vector3(0,0,0),d=-1,h,u,_){if(this.index=c.index,c.index++,this.cm_pos=e.clone(),this._a1=n.clone().normalize(),this._a3=o.clone().normalize(),"string"==typeof i)try{i=s[i]}catch(t){l.log(`Invalid base (${t})`)}this._base=i,this._L=r,this._v=a,this.n3=d,this.next=-1,this.pair=h,this.cluster=u,this.color=_}get pos_base(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(.4))}get pos_stack(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(.34))}get pos_back(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(-.4))}get pos_back_rel(){return this.pos_back.clone().sub(this.cm_pos)}get a2(){return this._a3.clone().cross(this._a1)}copy(t,e){let s=new c(this.cm_pos.clone(),this._a1.clone(),this._a3.clone(),this._base,this._L,this._v,this.n3,this.pair,this.cluster,this.color);return void 0!==t&&s.translate(t),void 0!==e&&s.rotate(e),s}translate(t){this.cm_pos.add(t),this.cm_pos_box.add(t)}rotate(t,e){void 0===e&&(e=this.cm_pos.clone()),this.cm_pos.sub(e).applyMatrix3(t).add(e),this._a1.applyMatrix3(t),this._a3.applyMatrix3(t)}distance(t,e=!0,s){e&&void 0===s&&l.die("distance between nucleotides: if PBC is true, box must be provided");let n=t.pos_back.clone().sub(this.pos_back);return e&&n.sub(s.clone().multiply(n.clone().divide(s).round())),n}get_base(){return[0,1,2,3].includes(this._base)?e[this._base]:this._base.toString()}_get_lorenzo_output(){return[this.cm_pos,this._a1,this._a3,this._v,this._L].map((t=>t.toArray().join(" "))).join(" ")}}c.index=0;class d{constructor(){this.index=d.index,d.index++,this._first=-1,this._last=-1,this._nucleotides=[],this._sequence=[],this._circular=!1}get N(){return this._nucleotides.length}get sequence(){return this._sequence}_prepare(t,e){this.index=t,this._first=e;let s=0;for(;s<this.N;)this._nucleotides[s].index=e+s,s++;return this._last=e+s,e+s+1}copy(){let t=new d;for(const e of this._nucleotides)t.add_nucleotide(e.copy());return t}get cm_pos(){let e=new t.Vector3;return this._nucleotides.forEach((t=>{e.add(t.cm_pos)})),e.divideScalar(this.N)}set cm_pos(t){const e=t.clone().sub(this.cm_pos);this._nucleotides.forEach((t=>t.translate(e)))}translate(t){let e=this.cm_pos.clone().add(t);this.cm_pos=e}rotate(t,e){void 0===e&&(e=this.cm_pos);for(const s of this._nucleotides)s.rotate(t,e)}append(t){let e=this._nucleotides.slice(-1)[0].distance(t._nucleotides[0],!1);Math.sqrt(e.dot(e))>1.0025&&l.log("WARNING: Strand.push(): strands seem too far apart. Assuming you know what you are doing.");let s=new d;for(const t of this._nucleotides)s.add_nucleotide(t);for(const e of t._nucleotides)s.add_nucleotide(e);return s}get_slice(t=0,e){if(void 0===e&&(e=this.N),e>this.N)throw`The given end parameter is larger than the number of nucleotides of the strand (${e} > ${this.N})`;let s=new d;for(let n=t;n<e;n++)s.add_nucleotide(this._nucleotides[n].copy());return s}set sequence(t){if("string"==typeof t&&(t=Array.from(t).map((t=>s[t]))),t.length==this._nucleotides.length){for(let e=0;e<this._nucleotides.length;e++)this._nucleotides[e]._base=t[e];this._sequence=t}else l.log("Cannot change sequence: lengths don't match",l.WARNING)}bring_in_box_nucleotides(t){let e=this.cm_pos.divide(t).round().multiply(t);for(const t of this._nucleotides)t.cm_pos_box=t.cm_pos.clone().sub(e)}add_nucleotide(t){0===this._nucleotides.length&&(this._first=t.index),t.strand=this.index,this._nucleotides.push(t),this._last=t.index,this._sequence.push(t._base)}_get_lorenzo_output(){let t=this._nucleotides.map((t=>t._get_lorenzo_output())).join("\n")+"\n",e="";for(const t of this._nucleotides){let s,n;this._circular?(s=t.index===this._first?this._last:t.index-1,n=t.index===this._last?this._first:t.index+1):(s=t.index===this._first?-1:t.index-1,n=t.index===this._last?-1:t.index+1),e+=`${this.index+1} ${t.get_base()} ${s} ${n}\n`}return[t,e]}get_lammps_N_of_bonds_strand(){let t=0;for(const e of this._nucleotides)(e.index!=this._last||this._circular)&&t++;return t}get_lammps_bonds(){let t=[];for(const e of this._nucleotides)e.index!=this._last?t.push(`${e.index+1}  ${e.index+2}`):this._circular&&t.push(`${e.index+1}  ${this._first+1}`);return t}make_circular(t=!1){if(t){let t=this._nucleotides.slice(-1)[0].distance(this._nucleotides[0],!1);Math.sqrt(t.dot(t))>1.0025&&l.log("Strand.make_circular(): ends of the strand seem too far apart. Assuming you know what you are doing.",l.WARNING)}this._circular=!0}make_noncircular(){this._circular=!1}is_circular(){return this._circular}cut_in_two(t=!0){let e=new d,s=new d,n=0;for(const o of this._nucleotides)n<this._nucleotides.length/2?e.add_nucleotide(t?o.copy():o):s.add_nucleotide(t?o.copy():o),n++;return[e,s]}}d.index=0;class h{constructor(t,e=0,s=0,n=0){this._time=e,this._ready=!1,this._box=t,this._N=0,this._N_strands=0,this._strands=[],this._nucleotide_to_strand=[],this.E_pot=s,this.E_kin=n,this.E_tot=s+n,c.index=0,d.index=0}get sequences(){return this._strands.map((t=>t._sequence))}get N(){return this._N}get N_strands(){return this._N_strands}_prepare(){let t=0;for(let e=0;e<this._N_strands;e++)t=this._strands[e]._prepare(e,t);for(const t of this._strands)t.bring_in_box_nucleotides(this._box)}copy(){let t=new h(this._box);for(const e of this._strands)t.add_strand(e.copy());return t}join(e,s){if(void 0===s){s=new t.Vector3(0,0,0);for(let t=0;t<3;t++)e._box[t]>this._box[t]?s[t]=e._box[t]:s[t]=this._box[t]}let n=new h(s);for(const t of this._strands)n.add_strand(t.copy());for(const t of e._strands)n.add_strand(t.copy());return n}add_strand(t){return this._strands.push(t),this._N+=t.N,this._N_strands++,!0}add_strands(t){if(Array.isArray(t)){let e=[];for(const s of t)this.add_strand(s)&&e.push(s);if(e.length===t.length)return!0;for(const t of e)c.index-=t.N,d.index--,this._strands.pop(),this._N-=t.N,this._N_strands--;return!1}return!!this.add_strand(t)}rotate(t,e){for(const s of this._strands)s.rotate(t,e)}translate(t){for(const e of this._strands)e.translate(t)}print_lorenzo_output(){let t=`t = ${this._time}\nb = ${this._box.x} ${this._box.y} ${this._box.z}\nE = ${this.E_tot} ${this.E_pot} ${this.E_kin}\n`,e=0,s=0;for(const t of this._strands)e++,s+=t.N;let n=`${s} ${e}\n`;for(const e of this._strands){let[s,o]=e._get_lorenzo_output();n+=o,t+=s}return[n,t]}print_oxview_output(){let t={box:this._box.round().toArray(),systems:[{id:0,strands:[]}]};for(const e of this._strands){let s={id:e.index,end3:e._nucleotides[0].index,end5:e._nucleotides.slice(-1)[0].index,class:"NucleicAcidStrand",monomers:[]};for(let t=0;t<e.N;t++){let n,o,i=e._nucleotides[t];e._circular?(o=0===t?e._nucleotides.slice(-1)[0].index:e._nucleotides[t-1].index,n=t===e._nucleotides.length-1?e._nucleotides[0].index:e._nucleotides[t+1].index):(o=0===t?-1:e._nucleotides[t-1].index,n=t===e._nucleotides.length-1?-1:e._nucleotides[t+1].index);let a={id:i.index,type:i.get_base(),class:"DNA",p:i.cm_pos.toArray(),a1:i._a1.toArray(),a3:i._a3.toArray()};o>=0&&(a.n3=o),n>=0&&(a.n5=n),void 0!==i.pair&&(a.bp=i.pair.index),void 0!==i.cluster&&(a.cluster=i.cluster),void 0!==i.color&&(a.color=i.color),s.monomers.push(a)}t.systems[0].strands.push(s)}return JSON.stringify(t)}get _nucleotides(){return[].concat(...this._strands.map((t=>t._nucleotides)))}map_nucleotides_to_strands(){for(let t=0;t<this._strands.length;t++)for(let e=0;e<this._strands[t].N;e++)this._nucleotide_to_strand.push(t)}print_dot_bracket_output(){let t="";for(let e=0;e<this.N;e++){let s=this._nucleotides[e].interactions;s.length>1&&l.log("more than 1 HB for a nucleotide",l.WARNING),0===s.length?t+=".":s[0]>e?t+="(":s[0]<e?t+=")":l.log("unexpected interaction detected while building nupack string",l.CRITICAL)}return t}}function u(...t){return t.reduce(((t,e)=>t+e),0)}function _(t,e,s=1){void 0===e&&(e=t,t=0);let n=[];for(let o=t;o<e;o+=s)n.push(o);return n}function p(t,e,s=1){void 0===e&&(e=t,t=0);var n=[];for(let o=0;o<s;o++)n[o]=t+Math.floor(Math.random()*(e-t));return 1===s?n[0]:n}function f(t,e){if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var s=0;s<t.length;++s)if(t[s]!==e[s])return!1;return!0}function g(t,e,s){t=t.clone(),e=e.clone(),s=s.clone();const n=t.dot(t),o=e.dot(t);e.sub(t.clone().multiplyScalar(o/n));const i=s.dot(t),a=s.dot(e),r=e.dot(e);return s.sub(t.clone().multiplyScalar(i/n).add(e.clone().multiplyScalar(a/r))),t.divideScalar(n),e.divideScalar(r),s.divideScalar(Math.sqrt(s.dot(s))),[t,e,s]}function m(){let e,s,n=1;for(;n>=1;)e=1-2*Math.random(),s=1-2*Math.random(),n=e*e+s*s;const o=2*Math.sqrt(1-n);return new t.Vector3(e*o,s*o,1-2*n)}function b(){let[e,s,n]=g(m(),m(),m()),o=(new t.Matrix3).set(e.x,e.y,e.z,s.x,s.y,s.z,n.x,n.y,n.z);return o.determinant()<0&&(o=(new t.Matrix3).set(s.x,s.y,s.z,e.x,e.y,e.z,n.x,n.y,n.z)),o}class y{generate(e,n,o=new t.Vector3(0,0,0),i=new t.Vector3(0,0,1),h,u=0,_=!0,p=!1,f=0,g=10.34,m,b,y=!1){if("string"==typeof n)try{n=Array.from(n).map((t=>s[t]))}catch(t){l.die("Key Error: sequence is invalid")}let x=t=>Math.floor(Math.random()*t);if(void 0===n){n=new Array(e);for(let t=0;t<e;t++)n[t]=x(4)}else if(n.length!=e){let t=e-n.length;for(l.log(`sequence is too short, adding ${t} random bases`,l.WARNING);t--;)n.push(x(4))}p&&e<30&&l.log("sequence is too short! Proceed at your own risk",l.WARNING);let w=!0;p&&e<30&&!_&&(l.log("sequence is too short! Generating ssDNA without imposed helicity",l.WARNING),y||(w=!1)),void 0===m&&(m=0),void 0===b&&(b=e),m>b&&l.die("ds_end > ds_start"),b>e&&l.die("ds_end > bp");let M,v=Math.sqrt(i.dot(i));v<1e-10?(l.log("direction must be a valid vector, defaulting to (0, 0, 1)",l.WARNING),i=new t.Vector3(0,0,1)):i.divideScalar(v),h?M=h:(M=new t.Vector3(Math.random(),Math.random(),Math.random()),M.sub(i.clone().multiplyScalar(i.clone().dot(M))),M.normalize());let N,I,A,V=new d,$=M.clone().applyAxisAngle(i,u),S=o.clone(),q=i;if(p&&(N=M.clone().cross(i),I=2*Math.PI/e,A=.7525/Math.sqrt(2*(1-Math.cos(I)))),p&&w){for(let t=0;t<e;t++){let s=M.clone().multiplyScalar(r*Math.cos(t*I)).add(i.clone().multiplyScalar(r*Math.sin(t*I)));S.add(s),q=s.clone().normalize(),$=q.clone().cross(N),$.applyAxisAngle(q,t*(Math.round(Math.floor(e/g))+f)/e*2*Math.PI),V.add_nucleotide(new c(S.clone().sub($.clone().multiplyScalar(a)),$,q,n[t]))}V.make_circular(!0)}else if(p&&!w){for(let s=0;s<e;s++)S=new t.Vector3(Math.cos(s*I)*A+.34*Math.cos(s*I),Math.sin(s*I)*A+.34*Math.sin(s*I),0),$=new t.Vector3(Math.cos(s*I),Math.sin(s*I),0),V.add_nucleotide(new c(S,$,new t.Vector3(0,0,1),n[s]));V.make_circular(!0)}else for(let t=0;t<e;t++)V.add_nucleotide(new c(S.clone().sub($.clone().multiplyScalar(a)),$,q,n[t])),t!=e-1&&($.applyAxisAngle(i,35.9*Math.PI/180),S.add(q.multiplyScalar(r)));if(_){let t=new d;for(let e=b-1;e<=m;e--){let s=V._nucleotides[e];$=s._a1.clone().negate(),q=s._a3.clone().negate();let o=$.clone().multiplyScalar(-1.2).add(s.cm_pos);t.add_nucleotide(new c(o,$,q,3-n[e]))}return 0===m&&b===e&&p&&t.make_circular(!0),[V,t]}return V}generate_or_sq(e,s,n=new t.Vector3(0,0,0),o=new t.Vector3(0,0,1),i,h=!0,u=0,_=Math.PI/180*33.75,f=[],g=[],m=[]){if(f&&g.length!=m.length&&(m.length+1===g.length?(l.log(`the lengths of begin ${g.length} and end ${m.length} arrays are mismatched; I will try to proceed by using the number of basepairs as the last element of the end array`,l.WARNING),m.push(e+1)):l.die(`the lengths of begin ${g.length} and end ${m.length} arrays are unrecoverably mismatched`)),void 0===s)s=p(0,4,e);else if(s.length!=e){let t=e-s.length;s+=p(0,4,t),l.log(`sequence is too short, adding ${t} random bases`,l.WARNING)}if(Array.isArray(_))_.length!=e-1&&l.log("generate_or_sq: incorrect angle array length, should be 1 less than number of base pairs",l.CRITICAL);else{let t=_;_=[];for(let s=0;s<e;s++)_.push(t)}let b=s.map((t=>3-t));b.reverse();let y,x=Math.sqrt(o.dot(o));x<1e-10?(l.log("direction must be a valid vector, defaulting to (0, 0, 1)",l.WARNING),o=new t.Vector3(0,0,1)):o.divideScalar(x),void 0===i?(y=new t.Vector3(Math.random(),Math.random(),Math.random()),y.sub(o.clone().multiplyScalar(o.clone().dot(y))),y.normalize()):y=i.clone();let w=new d,M=y.clone().applyAxisAngle(o,u),v=n.clone(),N=o.clone(),I=[];for(let n=0;n<e;n++)if(w.add_nucleotide(new c(v.clone().sub(M.clone().multiplyScalar(a)),M,N,s[n])),n!=e-1){let e=(new t.Quaternion).setFromAxisAngle(o,_[n]);if(I.push(e),M.applyQuaternion(e).normalize(),v.add(N.clone().normalize().multiplyScalar(r)),f)for(let t=0;t<f.length;t++)n>=g[t]&&n<m[t]&&f[t]&&v.add(N.clone().multiplyScalar(r*(-f[t]/(m[t]-g[t]))))}if(h){M.negate().normalize(),N=o.clone().negate().normalize();let t=new d;for(let s=0;s<e;s++){let n=w._nucleotides[e-s-1],o=new c(v.clone().sub(M.clone().multiplyScalar(a)),M.clone(),N.clone(),b[s],void 0,void 0,void 0,n);if(n.pair=o,t.add_nucleotide(o),s!=e-1&&(M.applyQuaternion(I.pop().conjugate()).normalize(),v.add(N.clone().multiplyScalar(r)),f))for(let t=0;t<f.length;t++)e-2-s>=g[t]&&e-2-s<m[t]&&f[t]&&v.add(N.clone().multiplyScalar(r*(-f[t]/(m[t]-g[t]))))}return[w,t]}return w}generate_double_offset(e,n,o,i=new t.Vector3(0,0,0),a=new t.Vector3(0,0,1),r,l=0){let c,d;c="string"==typeof e?[...e].map((t=>s[t])):e,d="string"==typeof n?[...n].map((t=>s[t])):n;let h=Math.max(c.length,d.length+o),u=this.generate(h,void 0,i,a,!1,void 0,!0),_=u[0],p=u[1];return _=_.get_slice(0,c.length),p=d.length+o>c.length?p.get_slice(0,d.length):p.get_slice(h-o-d.length,d.length),_.sequence=c,p.sequence=d,[_,p]}generate_rw(e,s=new t.Vector3(0,0,0)){l.log("Generating strand as a random walk. Remember to equilibrate the configuration with MC",l.WARNING);let n=new t.Vector3(.7525,0,0),o=s,i=[];i.push(o);for(let t=1;t<e.length;t++){let t,e=!0;for(;e;){e=!1;let s=b(),a=n.clone().applyMatrix3(s);t=o.clone().add(n.clone().applyMatrix3(s)),e=!1;for(const s of i)a=t.clone().sub(s),a.dot(a)<.4*.4&&(e=!0)}o=t,i.push(o)}let a=[];n=i[1].clone().sub(i[0]),a.push(n.clone().divideScalar(Math.sqrt(n.dot(n))));for(let t=1;t<i.length-1;t++)n=i[t+1].clone().add(i[t-1]).multiplyScalar(.5),n=i[t].clone().sub(n),a.push(n.clone().divideScalar(Math.sqrt(n.dot(n))));n=i[i.length-1].clone().sub(i[i.length-2]),a.push(n.divideScalar(Math.sqrt(n.dot(n))));let r=new d;for(let t=0;t<i.length;t++){let s=i[t],[n,o,l]=g(a[t],m(),m()),d=s+a[t]*Math.abs(-.4);r.add_nucleotide(new c(d,n,l,e[t]))}return r}}class x{constructor(){this.map=new Map}set(t,e){this.map.set(t.toString(),e)}get(t){return this.map.get(t.toString())}has(t){return this.map.has(t.toString())}get size(){return this.map.size}*keys(){for(let t of this.map.keys())yield t.split(",").map((t=>parseInt(t)))}*entries(){for(let[t,e]of this.map.entries()){let s=t.split(",").map((t=>parseInt(t)));yield[s,e]}}values(){return this.map.values()}}class w extends x{constructor(){super(),this._scaf=new x,this._stap=new x,this.nuc_count=0,this.strand_count=0}add_scaf(t,e,s,n){this._scaf.set([t,e],[s,n])}add_stap(t,e,s,n){this._stap.set([t,e],[s,n])}add_scaf_strand(t,e,s=!1){let n=0;const o=this._scaf.size;for(const[[s,o],[i,a]]of e._scaf.entries())i===t&&(this.add_scaf(s,o,this.strand_count,a.map((t=>t+this.nuc_count))),n+=a.length);return this.nuc_count+=n,this._scaf.size===o?1:(s||this.strand_count++,0)}add_stap_strand(t,e,s=!1){let n=0;const o=this._stap.size;for(const[[s,o],[i,a]]of e._stap.entries())i===t&&(this.add_stap(s,o,this.strand_count,a.map((t=>t+this.nuc_count))),n+=a.length);return this.nuc_count+=n,this._stap.size===o?1:(s||this.strand_count++,0)}add_strand(t,e,s=!1){return this.add_scaf_strand(t,e,s)&&this.add_stap_strand(t,e,s)}}const M=2.55,v=2.6;class N{constructor(){this.begin=[],this.end=[]}toString(){return`${this.begin} ${this.end}`}add_begin(t){this.begin.includes(t)||this.begin.push(t)}add_end(t){this.end.includes(t)||this.end.push(t)}}function I(t,e,s,n,o,i,a,r,l,c,d,h){let _,p,f=0,g=0;if((e.num%2+h)%2==0){for(const t of e.skip.slice(0,s))f-=t;for(const t of e.skip.slice(0,n+1))g-=t;for(const t of e.loop.slice(0,s))f+=t;for(const t of e.loop.slice(0,n+1))g+=t;_=s+f,p=n+1+g}else{for(const t of e.skip.slice(n))g-=t;for(const t of e.skip.slice(s+1))f-=t;for(const t of e.loop.slice(n))g+=t;for(const t of e.loop.slice(s+1))f+=t;_=e.len-s-1+f,p=e.len-n+g}let m=function(t,e,s,n,o,i,a){let r,l=[],c=0,d=new N,h=[],_=o.slice();i.num%2==1&&(r=new N,r.begin=a.begin.slice().reverse(),r.end=a.end.slice().reverse());for(let t=0;t<a.begin.length;t++){let e,s,n,p;if(i.num%2==0?(e=a.begin[t],p=a.end[t],s=a.begin[t],n=a.end[t]):(e=r.end[t],p=r.begin[t],s=i.len-r.begin[t]-1,n=i.len-r.end[t]-1),n-s!=0){l.push(0);for(const s of i.skip.slice(e,p+1))l[t]-=s;for(const s of i.loop.slice(e,p+1))l[t]+=s;h.push(u(...o.slice(s,n))/(n-s+l[t]));for(let e=s;e<n;e++)_[e]=h[t];s+=c,n+=c+l[t],d.add_begin(s),d.add_end(n)}else l.push(0),h.push(u(...o)/o.length),s+=c,n+=c+l[t],d.add_begin(s),d.add_end(n);c+=l[t]}let p=0,f=0,g=0,m=0;for(let t=0;t<a.begin.length;t++){let e,s,n,o;p+=g,f+=m,g=0,m=0,i.num%2==0?(e=a.begin[t],s=a.end[t],n=a.begin[t],o=a.end[t]):(e=r.end[t],s=r.begin[t],n=i.len-r.begin[t]-1,o=i.len-r.end[t]-1);for(const t of i.skip.slice(e,s+1))1===t&&(_.splice(n-p+f,1),g++);for(const o of i.loop.slice(e,s+1))for(let e=0;e<o;e++)_.splice(n-p+f,0,h[t]),m++}return(new y).generate_or_sq(_.length+1,void 0,t,e,s,!0,n,_,l,d.begin,d.end)}(a,r,l,c,d,e,o);return t.add_strand(m[h].get_slice(_,p)),t}function A(t,e,s,n,o,i){let a,r=0,l=0,c=0;if((t.num%2+i)%2==0){for(const e of t.skip.slice(s,n+1))r-=e;for(const e of t.loop.slice(s,n+1))r+=e}else{for(const e of t.skip.slice(n,s+1))r-=e;for(const e of t.loop.slice(n,s+1))r+=e}a=(i+t.num%2)%2==0?n-s+1+r:s+1-n+r;let d=0;for(;d<a;){let n;if(n=(i+t.num%2)%2==0?d+s+l-c:s-d-l+c,1!=t.skip[n]){let s;s=(i+t.num%2)%2==0?_(t.loop[n]+1).map((t=>d+t)):_(t.loop[n]+1).reverse().map((t=>d+t)),0===i?o.set([t.num,n],[e,[d]]):1===i?o.set([e,d],[t.num,[n]]):2===i?o.add_scaf(t.num,n,e,s):3===i&&o.add_stap(t.num,n,e,s),d+=1+t.loop[n],c+=t.loop[n]}else 2===i?o.add_scaf(t.num,n,e,[]):3===i&&o.add_stap(t.num,n,e,[]),l++}return o}function V(t){let e=new N,s=-1;t.num%2==0&&(s=1);for(let n=0;n<t.scaf.length;n++){let o,i,a,r,l=n-1*s,c=n+1*s;_(t.scaf.length).includes(l)?(o=t.scaf[l].type(t,l),i=t.stap[l].type(t,l)):(o=!1,i=!1),_(t.scaf.length).includes(c)?(a=t.scaf[c].type(t,c),r=t.stap[c].type(t,c)):(a=!1,r=!1),(o!==i||"begin"!==o&&"end"!==o)&&(a!==r||"begin"!==a&&"end"!==a)&&("empty"===t.scaf[n].type(t,n)?"begin"===t.stap[n].type(t,n)?e.add_end(n):"end"===t.stap[n].type(t,n)&&e.add_begin(n):"begin"===t.scaf[n].type(t,n)?"empty"===t.stap[n].type(t,n)?e.add_begin(n):"continue"===t.stap[n].type(t,n)?(e.add_begin(n),e.add_end(n-1*s)):"begin"===t.stap[n].type(t,n)?(e.add_begin(n+1*s),e.add_end(n-1*s)):"end"===t.stap[n].type(t,n)&&e.add_begin(n):"end"===t.scaf[n].type(t,n)?"empty"===t.stap[n].type(t,n)?e.add_end(n):"continue"===t.stap[n].type(t,n)?(e.add_begin(n+1*s),e.add_end(n)):"begin"===t.stap[n].type(t,n)?e.add_end(n):"end"===t.stap[n].type(t,n)&&(e.add_begin(n+1*s),e.add_end(n-1*s)):"continue"===t.scaf[n].type(t,n)&&("begin"===t.stap[n].type(t,n)?(e.add_begin(n+1*s),e.add_end(n)):"end"===t.stap[n].type(t,n)&&(e.add_begin(n),e.add_end(n-1*s))))}return e}function $(e,s,n){let o=new y,i=new Array(n.len-1);for(let t=0;t<i.length;t++){let e=t%32;e<2?i[t]=28*Math.PI/180:2===e?i[t]=36*Math.PI/180:3===e?i[t]=54.375*Math.PI/180:4===e?i[t]=37*Math.PI/180:[5,6].includes(e)?i[t]=27.6666666666666*Math.PI/180:7===e?i[t]=30.6666666666666*Math.PI/180:[8,9].includes(e)?i[t]=29.3333333333*Math.PI/180:10===e?i[t]=34.3333333333*Math.PI/180:11===e?i[t]=54.5*Math.PI/180:[12,13].includes(e)?i[t]=28.91666666666*Math.PI/180:[14,15,16,17].includes(e)?i[t]=31.16666666666*Math.PI/180:18===e?i[t]=35.5*Math.PI/180:19===e?i[t]=52*Math.PI/180:20===e?i[t]=35.5*Math.PI/180:[21,22].includes(e)?i[t]=27.5*Math.PI/180:i[t]=23===e?35.5*Math.PI/180:e>=24&&e<27?30*Math.PI/180:27===e?52*Math.PI/180:28===e?35.5*Math.PI/180:Math.PI/180*30.91666666666}let a,l,c,d,h,_=0;for(let t=0;t<31;t++)_+=i[t];for(let t=0;t<i.length;t++)t%32==31&&(i[t]=1080*Math.PI/180-_);return n.num%2==0?(a=new t.Vector3(n.col*v,n.row*v,0),l=e.clone(),c=s.clone(),d=0,h=i.slice()):(a=new t.Vector3(n.col*v,n.row*v,(n.len-1)*r),l=e.clone().negate(),c=s.clone().negate(),d=-u(...i)%(2*Math.PI),h=i.slice().reverse()),[o.generate_or_sq(n.len,void 0,a,l,c,!0,d,h),i,a,d,l,c]}function S(e,s,n){let o=new y,i=new Array(n.len-1);for(let t=0;t<i.length;t++){const e=t%21;0===e?i[t]=32.571*Math.PI/180:1===e?i[t]=36*Math.PI/180:[1,2,3].includes(e)?i[t]=42*Math.PI/180:[5,6,7].includes(e)?i[t]=29.143*Math.PI/180:8===e?i[t]=32*Math.PI/180:[9,10].includes(e)?i[t]=44*Math.PI/180:[12,13,14].includes(e)?i[t]=28.571*Math.PI/180:[16,17].includes(e)?i[t]=41.5*Math.PI/180:[19,20].includes(e)?i[t]=28.476*Math.PI/180:i[t]=720/21*(Math.PI/180)}let a,l,c,d,h,_=0;for(let t=0;t<20;t++)_+=i[t];for(let t=0;t<i.length;t++)t%21==20&&(i[t]=720*Math.PI/180-_);if(n.num%2==0)a=new t.Vector3(n.col*Math.sqrt(3)*M/2,3*n.row*M/2,0),l=e.clone(),c=s.clone(),d=0,h=o.generate_or_sq(n.len,void 0,a,l,c,!0,d,i);else{a=new t.Vector3(n.col*Math.sqrt(3)*M/2,3*n.row*M/2+1.275,(n.len-1)*r),l=e.clone().negate(),c=s.clone().negate(),d=-u(...i)%(2*Math.PI);let _=i.slice().reverse();h=o.generate_or_sq(n.len,void 0,a,l,c,!0,d,_)}return[h,i,a,d,l,c]}class q{constructor(){this.vhelices=[]}add_vhelix(t){this.vhelices.push(t)}bbox(){let t=[],e=[],s=[];for(const n of this.vhelices)t.push(n.row),e.push(n.col),s.push(n.stap.length);const n=v*(Math.max(...t)-Math.min(...t)+2),o=v*(Math.max(...e)-Math.min(...e)+2),i=.34*(Math.max(...s)+2);return 2*Math.max(n,o,i)*2}toString(){let t='{\n"vstrands":[\n';if(this.vhelices.length>0){for(const e of this.vhelices)t+=`${e},`;t=t.slice(0,t.length-1)}return t+="}\n",t}}class k{constructor(){this.stapLoop=[],this.scafLoop=[],this.skip=[],this.loop=[],this.stap_colors=[],this.row=0,this.col=0,this.num=0,this.stap=[],this.scaf=[],this.cad_index=-1,this.skiploop_bases=0}get len(){return Math.max(this.scaf.length,this.stap.length)}add_square(t,e){"stap"===e?this.stap.push(t):"scaf"===e?this.scaf.push(t):l.log("Cannot add square that is not scaf or stap. Dying now",l.CRITICAL)}toString(){let t="{\n";if(t+='"stapLoop":[',this.stapLoop.length>0){for(const e of this.stapLoop)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"skip":[',this.skip.length>0){for(const e of this.skip)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"loop":[',this.loop.length>0){for(const e of this.loop)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"stap_colors":[',this.stap_colors.length>0){for(const e of this.stap_colors)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+=`"row":${this.row},\n`,t+=`"col":${this.col},\n`,t+=`"num":${this.num},\n`,t+='"scafLoop":[',this.scafLoop.length>0){for(const e of this.scafLoop)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"stap":[',this.stap.length>0){for(const e of this.stap)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"scaf":[',this.scaf.length>0){for(const e of this.scaf)t+=`${e},`;t=t.slice(0,t.length-1)}return t+="]\n}",t}}class P{constructor(t=-1,e=-1,s=-1,n=-1){this.V_0=t,this.b_0=e,this.V_1=s,this.b_1=n}toString(){return`[${this.V_0},${this.b_0},${this.V_1},${this.b_1}]`}type(t,e){if(-1===this.V_0&&-1===this.b_0){if(-1===this.V_1&&-1===this.b_1)return"empty";if(this.V_1===t.num&&1===Math.abs(this.b_1-e))return"begin"}else{if(this.V_0===t.num&&1===Math.abs(this.b_0-e))return-1===this.V_1?"end":this.V_1===t.num&&1===Math.abs(this.b_1-e)?"continue":"end";if(this.V_1===t.num&&1===Math.abs(this.b_1-e))return"begin"}l.log("unexpected square array",l.WARNING)}}function C(t,e,s){let n=.4*parseFloat(s)/2;return t.clone().sub(e.clone().multiplyScalar(n))}const R=1/8.518,G=new Map([["ADE","A"],["CYT","C"],["GUA","G"],["THY","T"],["URA","U"]]),z=["A","T","G","C","U"];let W=!1;class E{constructor(t,e){this.name=t.trim(),[...G.keys()].includes(this.name)?this.base=G[this.name]:this.name in z?("U"!=this.name||W||(l.log("WARNING: unsupported uracil detected: use at your own risk"),W=!0),this.base=this.name):this.base=t.slice(1),this.idx=e,this.base_atoms=[],this.phosphate_atoms=[],this.sugar_atoms=[],this.named_atoms={},this.ring_names=["C2","C4","C5","C6","N1","N3"]}get atoms(){return[].concat(this.base_atoms,this.phosphate_atoms,this.sugar_atoms)}add_atom(t){t.name.includes("P")||"HO5'"==t.name?this.phosphate_atoms.push(t):t.name.includes("'")?this.sugar_atoms.push(t):this.base_atoms.push(t),this.named_atoms[t.name]=t,void 0===this.chain_id&&(this.chain_id=t.chain_id)}get_com(e){null==e&&(e=this.atoms);let s=new t.Vector3(0,0,0);for(const t of e)s.add(t.pos);return s.divideScalar(e.length)}compute_a3(){const e=this.get_com(this.base_atoms),s=this.named_atoms["O4'"].pos.clone().sub(e);this.a3=new t.Vector3(0,0,0);for(const t of function*(t,e){let s=Array.from(t),n=s.length;if(3>n)return;let o=Array.from(_(n)),i=Array.from(_(n,n-3,-1)),a=t=>s[t];for(yield o.slice(0,3).map(a);n>0;){let t=!0;for(let e of _(2,-1,-1)){if(i[e]-=1,0!==i[e]){let s=i[e],[n,r]=[o[o.length-s],o[e]];o[e]=n,o[o.length-s]=r,yield o.slice(0,3).map(a),t=!1;break}o=o.slice(0,e).concat(o.slice(e+1)).concat(o.slice(e,e+1)),i[e]=n-e}if(t)return}}(this.ring_names)){let e=this.named_atoms[t[0]],n=this.named_atoms[t[1]],o=this.named_atoms[t[2]],i=e.pos.clone().sub(n.pos),a=e.pos.clone().sub(o.pos);if(i.divideScalar(Math.sqrt(i.dot(i))),a.divideScalar(Math.sqrt(a.dot(a))),Math.abs(i.dot(a))>.01){let t=i.clone().cross(a);t.divideScalar(Math.sqrt(t.dot(t))),t.dot(s)<0&&t.negate(),this.a3.add(t)}}this.a3.divideScalar(Math.sqrt(this.a3.dot(this.a3)))}compute_a1(){let e;e=this.name.includes("C")||this.name.includes("T")||this.name.includes("U")?[["N3","C6"],["C2","N1"],["C4","C5"]]:[["N1","C4"],["C2","N3"],["C6","C5"]],this.a1=new t.Vector3(0,0,0);for(const t of e){let e=this.named_atoms[t[0]],s=this.named_atoms[t[1]],n=e.pos.clone().sub(s.pos);this.a1.add(n)}this.a1.divideScalar(Math.sqrt(this.a1.dot(this.a1)))}compute_as(){this.compute_a1(),this.compute_a3(),this.a2=this.a3.clone().cross(this.a1),this.check=Math.abs(this.a1.dot(this.a3))}correct_for_large_boxes(t){for(const s of this.atoms)s.shift((e=s.pos/t,-Math.sign(e)*Math.round(Math.abs(e))*t));var e}to_pdb(t,e,s,n,o){let i,a,r,l,c=[];for(const l of this.atoms)if(e||!l.name.includes("H")){if("5"==o){if("P"in l.name){"P"==l.name&&(i=l);continue}"O5'"==l.name&&(a=l)}else"3"==o&&"O3'"==l.name&&(r=l);c.push(l.to_pdb(t,s,n))}if("5"==o){let e=i.clone();e.name="HO5'";let o=i.pos.sub(l.pos);o.multiplyScalar(1/Math.sqrt(o.dot(o))),e.pos=l.pos.clone().add(o),c.push(e.to_pdb(t,s,n))}else if("3"==o){let e=r.clone();e.name="HO3'";let o=this.a2.clone().multiplyScalar(.2).sub(this.a1.clone().multiplyScalar(.2)).sub(this.a3);o.multiplyScalar(1/Math.sqrt(o.dot(o))),e.pos=r.pos.clone().add(o),c.push(e.to_pdb(t,s,n))}return c.join("\n")}to_mgl(){let t=[];for(const e of this.atoms)t.push(e.to_mgl());return t.join("\n")}rotate(t){let e=this.get_com();for(const s of this.atoms)s.pos=t.dot(s.pos.clone().sub(e)).add(e);this.compute_as()}set_com(t){let e=this.get_com();for(const s of this.atoms)s.pos.add(t.sub(e).sub(this.a1.clone().multiplyScalar(.5)))}}class O{constructor(e){this.name=e.slice(12,16).trim(),this.name.includes("*")&&(this.name=this.name.replace("*","'")),this.alternate=e[16],this.residue=e.slice(17,20).trim(),this.chain_id=e.slice(21,22).trim(),this.residue_idx=parseInt(e.slice(22,26)),this.pos=new t.Vector3(parseFloat(e.slice(30,38)),parseFloat(e.slice(38,46)),parseFloat(e.slice(46,54)))}clone(){let t=new O("");return t.name=this.name.slice(),t.alternate=this.alternate.slice(),t.residue=this.residue.slice(),t.chain_id=this.chain_id.slice(),t.residue_idx=this.residue_idx,t.pos=this.pos.clone(),t}is_hydrogen(){this.name.includes("H")}shift(t){this.pos.add(t)}to_pdb(t,e,s){let n=this.residue+s,o=(t,e)=>`${t}`.padStart(e," "),i=`ATOM  ${o(O.serial_atom,5)} ${o(this.name,4)} ${o(n,3)} ${o(t,3)}${o(e,1)}    ${o(this.pos.x.toFixed(3),8)}${o(this.pos.y.toFixed(3),8)}${o(this.pos.z.toFixed(3),8)}  1.00  0.00              `;return O.serial_atom++,O.serial_atom>99999&&(O.serial_atom=1),i}}function T(e,n,o,i){let a;switch(n){case"cadnano":a=function(e,n,o,i){let a=!1,r=!1;if("sq"===n)a=!0;else{if("he"!==n)return void alert("Lattice_type should be either 'sq' or 'he'");r=!0}let p=new w,g=new w,m=function(t){let e=new q,s=JSON.parse(t);for(const t of s.vstrands){let s=new k;for(const[e,n]of Object.entries(t))"skip"===e?s.skip=n.map((t=>Math.abs(t))):s[e]="stap"===e||"scaf"===e?n.map((t=>new P(...t))):n;s.skiploop_bases=s.skip.length+u(...s.loop)-u(...s.skip),e.add_vhelix(s)}return e}(e),b=0;void 0===i&&(i=m.bbox(),l.log("Using default box size, a factor 2 larger than the size of the cadnano system",l.INFO));let y=new t.Vector3(0,0,1),M=new t.Vector3(1,0,0);var v;a?(v=y,M=M.clone().applyAxisAngle(v,15*Math.PI/180)):r&&(M=function(t,e){return e.clone().applyAxisAngle(t,160*Math.PI/180)}(y,M));let N=new h(new t.Vector3(i,i,i)),C=new h(new t.Vector3(i,i,i)),R=-1,G=[],z=[],W=!1,E=[],O=[],T=-1,F=-1;for(const t of m.vhelices){let e,s,n,o,i,c;t.cad_index=b,a?[e,s,n,o,i,c]=$(y,M,t):r&&([e,s,n,o,i,c]=S(y,M,t));let d=V(t),h=0;for(const e of t.scaf){if(-1===e.V_0&&-1===e.b_0)-1===e.V_1&&-1===e.b_0||(e.V_1===t.num&&1===Math.abs(e.b_1-h)?(t.num%2==0&&R++,T=h,t.num%2==1&&(N=I(N,t,T,F,d,0,n,i,c,o,s,0),p=A(t,R,T,F,p,2))):l.log("unexpected square array",l.WARNING));else if(e.V_0===t.num&&1===Math.abs(e.b_0-h))if(-1===e.V_1&&-1===e.b_1)t.num%2==1&&R++,F=h,t.num%2==0&&(N=I(N,t,T,F,d,0,n,i,c,o,s,0),p=A(t,R,T,F,p,2));else if(e.V_1===t.num&&1===Math.abs(e.b_1-h));else{let a;t.num%2==1&&R++,F=h,t.num%2==0&&(N=I(N,t,T,F,d,0,n,i,c,o,s,0),p=A(t,R,T,F,p,2)),t.num,a=h;for(let e=0;e<G.length;e++)f([t.num,a],G[e])&&(E[e].splice(0,0,R),W=!0);W||(E.push([R]),G.push([e.V_1,e.b_1])),W=!1}else if(-1===e.V_1&&-1===e.b_1)l.log("unexpected square array",l.WARNING);else if(e.V_1===t.num&&1===Math.abs(e.b_1-h)){t.num%2==0&&R++,T=h,t.num%2==1&&(N=I(N,t,T,F,d,0,n,i,c,o,s,0),p=A(t,R,T,F,p,2));for(let e=0;e<G.length;e++){let s;t.num,s=h,f([t.num,s],G[e])&&(E[e].push(R),W=!0)}W||(E.push([R]),G.push([e.V_0,e.b_0])),W=!1}else l.log("unexpected square array",l.WARNING);h++}if(0!==N.N_strands){h=0;for(const e of t.stap){if(-1===e.V_0&&-1===e.b_0)-1===e.V_1&&-1===e.b_0||(e.V_1===t.num&&1===Math.abs(e.b_1-h)?(t.num%2==1&&R++,T=h,t.num%2==0&&(N=I(N,t,T,F,d,0,n,i,c,o,s,1),p=A(t,R,T,F,p,3))):l.log("unexpected square array",l.WARNING));else if(e.V_0===t.num&&1===Math.abs(e.b_0-h))if(-1===e.V_1&&-1===e.b_1)t.num%2==0&&R++,F=h,t.num%2==1&&(N=I(N,t,T,F,d,0,n,i,c,o,s,1),p=A(t,R,T,F,p,3));else if(e.V_1===t.num&&1===Math.abs(e.b_1-h));else{t.num%2==0&&R++,F=h,t.num%2==1&&(N=I(N,t,T,F,d,0,n,i,c,o,s,1),p=A(t,R,T,F,p,3));let a=h;for(let e=0;e<z.length;e++)f([t.num,a],z[e])&&(O[e].splice(0,0,R),W=!0);W||(O.push([R]),z.push([e.V_1,e.b_1])),W=!1}else if(-1===e.V_1&&-1===e.b_1)l.log("unexpected square array",l.WARNING);else if(e.V_1===t.num&&1===Math.abs(e.b_1-h)){t.num%2==1&&R++,T=h,t.num%2==0&&(N=I(N,t,T,F,d,0,n,i,c,o,s,1),p=A(t,R,T,F,p,3));for(let e=0;e<z.length;e++){let s=h;f([t.num,s],z[e])&&(O[e].push(R),W=!0)}W||(O.push([R]),z.push([e.V_0,e.b_0])),W=!1}else l.log("unexpected square array",l.WARNING);h++}b++}else l.log(`No scaffold strand found in virtual helix n. ${t.num}: staples-only virtual helices are not supported`,l.WARNING)}let L,j=[E,O],D=[];for(let t=0;t<2;t++)for(const e of j[t])D.push(...e);for(let t=0;t<N._strands.length;t++)D.includes(t)||(C.add_strand(N._strands[t]),g.add_strand(t,p));for(let t=0;t<2;t++){const e=j[t];let s=!1;L=!1;for(const t of e){let e=N._strands[t[0]],s=N._strands[t[1]],n=e._nucleotides.slice(-1)[0].distance(s._nucleotides[0],!1),o=Math.sqrt(n.dot(n));(o>1.0018||o<.5525)&&l.log(`The backbone-backbone distance across joints is ${o}: it will have to be relaxed with preliminary simulations`,l.WARNING)}let n=[];for(;!s;){L=!1;for(let t=0;t<e.length&&!L;t++)for(let s=0;s<e.length&&!L;s++)if(e[t][0]===e[s].slice(-1)[0]){if(t!=s){e[s].push(...e[t].slice(1)),e.splice(t,1),L=!0;break}n.includes(t)||n.push(t)}L||(s=!0)}for(let t=0;t<e.length;t++){const s=e[t];let o,i=N._strands[s[0]];if(n.includes(t)){for(const t of _(1,s.length-1))i=i.append(N._strands[s[t]]);i.make_circular(!0)}else for(const t of _(1,s.length))i=i.append(N._strands[s[t]]);C.add_strand(i),o=i._circular?_(s.length-2):_(s.length-1);for(const t of o)g.add_strand(s[t],p,!0);g.add_strand(s[o[o.length-1]+1],p,!1)}}let U=new h(C._box);for(const t of C._strands){let e=t._nucleotides.map((t=>t));e.reverse();let s=new d;for(const t of e)s.add_nucleotide(new c(t.cm_pos,t._a1,t._a3.clone().negate(),t._base));t._circular&&s.make_circular(),U.add_strand(s)}let H=new w,B=_(U._N_strands),Q=0;for(let t=0;t<U._strands.length;t++){const e=U._strands[t];B[t]=Q,Q+=e._nucleotides.length}let J=new Map;for(const[t,e]of g._scaf.keys()){let[s,n]=g._scaf.get([t,e]),o=[];for(const i of n){const n=U._strands[s]._nucleotides.length-1-(i-B[s])+B[s];o.push(n),J.set(n,[t,e])}H.add_scaf(t,e,s,o)}for(const[t,e]of g._stap.keys()){let[s,n]=g._stap.get([t,e]),o=[];for(const i of n){const n=U._strands[s]._nucleotides.length-1-(i-B[s])+B[s];o.push(n),J.set(n,[t,e])}H.add_stap(t,e,s,o)}if(0===U.N)return void l.log("The generated configuration is empty: this might be due to this conversion module not supporting virtual helices containing no scaffold strands.",l.CRITICAL);let Y=new x;for(const t of m.vhelices)for(const[e,s]of t.stap_colors)Y.set([t.num,e],s);let K=new x;for(const[t,e]of J.entries())K.has(e)||K.set(e,[]),K.get(e).push(t);let X=new Map;for(const t of U._strands)for(const e of t._nucleotides)X.set(e.index,e);let Z=[];for(const t of K.values())for(const e of t)try{Z.push(X.get(e).strand)}catch(t){console.log(`Could not find nucId ${e} strand`)}let tt=(et=Z,st={},et.forEach((function(t){st[t]=(st[t]||0)+1})),Object.keys(st).reduce((function(t,e,s){return!s||st[e]>st[t[0]]?[e]:(st[e]===st[t[0]]&&t.push(e),t)}),[]))[0];var et,st;let nt=new x;for(const t of U._strands)for(const e of t._nucleotides)if(J.has(e.index)){let[t,s]=J.get(e.index),n=K.get([t,s]);n.length>1&&(e.pair=X.get(n.filter((t=>t!=e.index))[0]));let o=K.get([t,s]).filter((t=>X.get(t).strand!=tt));if(o.length>0){let n=X.get(o[0]);const i=[t,n.strand];nt.has(i)||nt.set(i,nt.size+1),e.cluster=nt.get(i),e===n?Y.has([t,s])&&(e.color=Y.get([t,s])):e.color=3633362}else e.cluster=-1}for(const t of U._strands)for(const e of t._nucleotides)if(void 0!==e.color){for(const s of t._nucleotides)s.color=e.color;break}if(o){let t=U._strands[tt];if(t.N>o.length)l.log(`Provided scaffold sequence is ${o.length}nt but needs to be at least ${t.N} to cover the scaffold. Using random sequence instead.`);else for(let e=0;e<t.N;e++){let n=t._nucleotides[e];n._base=s[o[t.N-e-1]],n.pair&&(n.pair._base=3-n._base)}}return U}(e[0],i.grid,i.sequence,i.side);break;case"rpoly":a=function(e,n){let o=[],i=[],a=[],r=0;for(const t of e.split("\n"))t.startsWith("hb")?(o.splice(r,0,t.split(" ")),r+=1):t.startsWith("c")&&(t.includes("f3")?a.push([parseInt(t.match(/c helix_(.+?) /)[1]),parseInt(t.match(/\' helix_(.+?) /)[1])]):i.push([parseInt(t.match(/c helix_(.+?) /)[1]),parseInt(t.match(/\' helix_(.+?) /)[1])]));let c=new y,d=new h(new t.Vector3(100,100,100)),u=new h(new t.Vector3(100,100,100)),_=0;for(let e=0;e<o.length;e++){const s=o[e];let n=new t.Vector3(parseFloat(s[3]),parseFloat(s[4]),parseFloat(s[5])).divideScalar(.84),i=parseInt(s[2]),a=new t.Quaternion(parseFloat(s[6]),parseFloat(s[7]),parseFloat(s[8]),parseFloat(s[9])),r=new t.Vector3(0,0,1).applyQuaternion(a),l=new t.Vector3(.65,-.76,0).applyQuaternion(a),h=C(n,r,i);for(const t of h.toArray())t>_&&(_=t);let p=c.generate_or_sq(i,void 0,h,r,l);for(const t of[0,1])for(const s of p[t]._nucleotides)s.cluster=e+1;let[f,g]=p[1].cut_in_two(!1);d.add_strand(f),d.add_strand(g),u.add_strand(p[0])}let p=new h(new t.Vector3(3*_,3*_,3*_));for(const t of i){let e=2*t[0]-1,s=2*t[1]-2,n=d._strands[e];n=n.append(d._strands[s]),p.add_strand(n)}let f=u._strands[0];for(const t of a.slice(0,-1)){let e=t[1]-1,s=u._strands[e];f=f.append(s)}void 0!==n&&(f.N>n.length?l.log(`Provided scaffold sequence is ${n.length}nt but needs to be at least ${f.N} to cover the scaffold. Using random sequence instead.`):f._nucleotides.forEach(((t,e)=>{t._base=s[n[f.N-e-1]],t.pair&&(t.pair._base=3-t._base)}))),f.make_circular(),p.add_strand(f);let g=0,m=0;for(const t of p._strands)t.index=m++,t._nucleotides.forEach(((e,s)=>{e.index=g++,0===s?t._first=e.index:s==t.N-1&&(t._last=e.index)}));return p}(e[0],i.sequence);break;case"pdb":a=function(e,s,n){let o,i,a,r=[],u=[];for(let t of e.split("\n")){t=t.trim();let e=new O(t);if(t.startsWith("ATOM"))""!==i&&(e.chain_id!==i&&0!==u.length?(l.log(`WARNING: a TER statement separating different strands (${e.chain_id} and ${i}) is missing`),r.push(u),u=[]):e.chain_id===i&&0===u.length&&l.log(`WARNING: a TER statement separates strands having the same chain id (${e.chain_id})`)),""!==e.alternate&&("A"!==e.alternate&&"1"!==e.alternate||l.log(`Alternate location for atom '${e.name}' of residue '${e.residue}' encountered, using the line marked with the '${e.alternate}' character.`)),e.residue_idx!==o&&(a=new E(e.residue,e.residue_idx),s?u.push(a):u.splice(0,0,a),o=e.residue_idx),a.add_atom(e),i=e.chain_id;else if(t.startsWith("MODEL")){if(!n){let e=t.split(" ")[1];l.log(`MODEL line detected: using the first MODEL encountered (${e})`)}}else if(t.startsWith("ENDMDL")){if(!n)break;u.length>0&&(r.push(u),u=[])}else(t.startsWith("TER")||"END"===t&&0===r.length&&u.length>0)&&(r.push(u),u=[])}u.length>0&&r.push(u);let _=new t.Vector3(1e6,1e6,1e6),p=new t.Vector3(-1e6,-1e6,-1e6);for(const t of[].concat(...r)){let e=t.get_com();for(let t=0;t<3;t++)e.getComponent(t)<_.getComponent(t)?_.setComponent(t,e.getComponent(t)):e.getComponent(t)>p.getComponent(t)&&p.setComponent(t,e.getComponent(t))}let f=2*Math.max(...p.clone().sub(_).toArray())*R;f=Math.ceil(f);let g=new t.Vector3(f,f,f);l.log(`Using a box of size ${f} in oxDNA units (twice as big as the PDB bounding box size)`);let m=new h(g);for(const t of r){let e=new d;for(const s of t){s.compute_as();let t=s.get_com().clone().multiplyScalar(R),n=new c(t,s.a1,s.a3,s.base[0]);e.add_nucleotide(n)}m.add_strand(e)}return m}(e[0],i.strand_dir,i.models_as_strands);break;default:return void console.log("Unknown input format: "+n)}switch(o){case"oxview":return a.print_oxview_output();case"oxdna":return a.print_lorenzo_output();default:console.log("Unknown output format: "+n)}}O.serial_atom=1})(),o})()}));