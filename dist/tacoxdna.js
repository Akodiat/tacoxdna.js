!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("three")):"function"==typeof define&&define.amd?define(["three"],e):"object"==typeof exports?exports.tacoxdna=e(require("three")):t.tacoxdna=e(t.THREE)}(this,(function(t){return(()=>{"use strict";var e={807:e=>{e.exports=t}},s={};function n(t){var o=s[t];if(void 0!==o)return o.exports;var i=s[t]={exports:{}};return e[t](i,i.exports,n),i.exports}n.d=(t,e)=>{for(var s in e)n.o(e,s)&&!n.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var o={};return(()=>{n.r(o),n.d(o,{Logger:()=>g,convertFromTo:()=>F});var t=n(807);function e(...t){return t.reduce(((t,e)=>t+e),0)}function s(t,e,s=1){void 0===e&&(e=t,t=0);let n=[];for(let o=t;o<e;o+=s)n.push(o);return n}function i(t,e,s=1){void 0===e&&(e=t,t=0);var n=[];for(let o=0;o<s;o++)n[o]=t+Math.floor(Math.random()*(e-t));return 1===s?n[0]:n}function a(t,e=!1){const s=e?"T":"U",n=t=>t[Math.floor(Math.random()*t.length)];return[...t].map((t=>{if(["A","T","U","C","G"].includes(t))return t;switch(t.toUpperCase()){case"R":return n(["A","G"]);case"Y":return n(["C",s]);case"M":return n(["A","C"]);case"K":return n(["G",s]);case"S":return n(["C","G"]);case"W":return n(["A",s]);case"H":return n(["A","C",s]);case"B":return n(["C","G",s]);case"V":return n(["A","C","G"]);case"D":return n(["A","G",s]);case"N":return n(["A","C","G",s]);default:throw new Error(`Unknown base code ${t}`)}})).join("")}function r(t,e){if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var s=0;s<t.length;++s)if(t[s]!==e[s])return!1;return!0}function l(t,e,s){t=t.clone(),e=e.clone(),s=s.clone();const n=t.dot(t),o=e.dot(t);e.sub(t.clone().multiplyScalar(o/n));const i=s.dot(t),a=s.dot(e),r=e.dot(e);return s.sub(t.clone().multiplyScalar(i/n).add(e.clone().multiplyScalar(a/r))),t.divideScalar(n),e.divideScalar(r),s.divideScalar(Math.sqrt(s.dot(s))),[t,e,s]}function c(){let e,s,n=1;for(;n>=1;)e=1-2*Math.random(),s=1-2*Math.random(),n=e*e+s*s;const o=2*Math.sqrt(1-n);return new t.Vector3(e*o,s*o,1-2*n)}function d(){let[e,s,n]=l(c(),c(),c()),o=(new t.Matrix3).set(e.x,e.y,e.z,s.x,s.y,s.z,n.x,n.y,n.z);return o.determinant()<0&&(o=(new t.Matrix3).set(s.x,s.y,s.z,e.x,e.y,e.z,n.x,n.y,n.z)),o}const h={0:"A",1:"G",2:"C",3:"T"},u={A:0,a:0,G:1,g:1,C:2,c:2,T:3,t:3,U:3,u:3,D:4};let _;try{_=Number.EPSILON}catch(t){_=2220446049250313e-31}const p=.4+.2,f=.3897628551303122;class g{static log(t,e=g.INFO,s){void 0===e&&(e=g.INFO),e<g.debug_level||(null!=s&&g.debug_level===g.DEBUG?g.logFunction(`${g.messages[e]}: ${t} (additional info: '${s}')`):g.logFunction(`${g.messages[e]}: ${t}`))}static die(t){throw g.log(t,g.CRITICAL),t}}g.DEBUG=0,g.INFO=1,g.WARNING=2,g.CRITICAL=3,g.debug_level=g.INFO,g.messages=["DEBUG","INFO","WARNING","CRITICAL"],g.logFunction=console.log;class m{constructor(e,s,n,o,a=new t.Vector3(0,0,0),r=new t.Vector3(0,0,0),l=-1,c,d,h){if(this.index=m.index,m.index++,this.cm_pos=e.clone(),this._a1=s.clone().normalize(),this._a3=n.clone().normalize(),void 0===o&&(o=i(0,4)),"string"==typeof o)try{o=u[o]}catch(t){g.log(`Invalid base (${t})`)}this._base=o,this._L=r,this._v=a,this.n3=l,this.next=-1,this.pair=c,this.cluster=d,this.color=h}get pos_base(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(.4))}get pos_stack(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(.34))}get pos_back(){return this.cm_pos.clone().add(this._a1.clone().multiplyScalar(-.4))}get pos_back_rel(){return this.pos_back.clone().sub(this.cm_pos)}get a2(){return this._a3.clone().cross(this._a1)}copy(t,e){let s=new m(this.cm_pos.clone(),this._a1.clone(),this._a3.clone(),this._base,this._L,this._v,this.n3,this.pair,this.cluster,this.color);return void 0!==t&&s.translate(t),void 0!==e&&s.rotate(e),s}translate(t){this.cm_pos.add(t),this.cm_pos_box.add(t)}rotate(t,e){void 0===e&&(e=this.cm_pos.clone()),this.cm_pos.sub(e).applyMatrix3(t).add(e),this._a1.applyMatrix3(t),this._a3.applyMatrix3(t)}distance(t,e=!0,s){e&&void 0===s&&g.die("distance between nucleotides: if PBC is true, box must be provided");let n=t.pos_back.clone().sub(this.pos_back);return e&&n.sub(s.clone().multiply(n.clone().divide(s).round())),n}get_base(){return[0,1,2,3].includes(this._base)?h[this._base]:this._base.toString()}_get_lorenzo_output(){return[this.cm_pos,this._a1,this._a3,this._v,this._L].map((t=>t.toArray().join(" "))).join(" ")}}m.index=0;class b{constructor(){this.index=b.index,b.index++,this._first=-1,this._last=-1,this._nucleotides=[],this._sequence=[],this._circular=!1}get N(){return this._nucleotides.length}get sequence(){return this._sequence}_prepare(t,e){this.index=t,this._first=e;let s=0;for(;s<this.N;)this._nucleotides[s].index=e+s,s++;return this._last=e+s,e+s+1}copy(){let t=new b;for(const e of this._nucleotides)t.add_nucleotide(e.copy());return t}get cm_pos(){let e=new t.Vector3;return this._nucleotides.forEach((t=>{e.add(t.cm_pos)})),e.divideScalar(this.N)}set cm_pos(t){const e=t.clone().sub(this.cm_pos);this._nucleotides.forEach((t=>t.translate(e)))}translate(t){let e=this.cm_pos.clone().add(t);this.cm_pos=e}rotate(t,e){void 0===e&&(e=this.cm_pos);for(const s of this._nucleotides)s.rotate(t,e)}append(t){let e=this._nucleotides.slice(-1)[0].distance(t._nucleotides[0],!1);Math.sqrt(e.dot(e))>1.0025&&g.log("WARNING: Strand.push(): strands seem too far apart. Assuming you know what you are doing.");let s=new b;for(const t of this._nucleotides)s.add_nucleotide(t);for(const e of t._nucleotides)s.add_nucleotide(e);return s}get_slice(t=0,e){if(void 0===e&&(e=this.N),e>this.N)throw`The given end parameter is larger than the number of nucleotides of the strand (${e} > ${this.N})`;let s=new b;for(let n=t;n<e;n++)s.add_nucleotide(this._nucleotides[n].copy());return s}set sequence(t){if("string"==typeof t&&(t=Array.from(t).map((t=>u[t]))),t.length==this._nucleotides.length){for(let e=0;e<this._nucleotides.length;e++)this._nucleotides[e]._base=t[e];this._sequence=t}else g.log("Cannot change sequence: lengths don't match",g.WARNING)}bring_in_box_nucleotides(t){let e=this.cm_pos.divide(t).round().multiply(t);for(const t of this._nucleotides)t.cm_pos_box=t.cm_pos.clone().sub(e)}add_nucleotide(t){0===this._nucleotides.length&&(this._first=t.index),t.strand=this.index,this._nucleotides.push(t),this._last=t.index,this._sequence.push(t._base)}_get_lorenzo_output(){let t=this._nucleotides.map((t=>t._get_lorenzo_output())).join("\n")+"\n",e="";for(const t of this._nucleotides){let s,n;this._circular?(s=t.index===this._first?this._last:t.index-1,n=t.index===this._last?this._first:t.index+1):(s=t.index===this._first?-1:t.index-1,n=t.index===this._last?-1:t.index+1),e+=`${this.index+1} ${t.get_base()} ${s} ${n}\n`}return[t,e]}get_lammps_N_of_bonds_strand(){let t=0;for(const e of this._nucleotides)(e.index!=this._last||this._circular)&&t++;return t}get_lammps_bonds(){let t=[];for(const e of this._nucleotides)e.index!=this._last?t.push(`${e.index+1}  ${e.index+2}`):this._circular&&t.push(`${e.index+1}  ${this._first+1}`);return t}make_circular(t=!1){if(t){let t=this._nucleotides.slice(-1)[0].distance(this._nucleotides[0],!1);Math.sqrt(t.dot(t))>1.0025&&g.log("Strand.make_circular(): ends of the strand seem too far apart. Assuming you know what you are doing.",g.WARNING)}this._circular=!0}make_noncircular(){this._circular=!1}is_circular(){return this._circular}cut_in_two(t=!0){let e=new b,s=new b,n=0;for(const o of this._nucleotides)n<this._nucleotides.length/2?e.add_nucleotide(t?o.copy():o):s.add_nucleotide(t?o.copy():o),n++;return[e,s]}}b.index=0;class y{constructor(t,e=0,s=0,n=0){this._time=e,this._ready=!1,this._box=t,this._N=0,this._N_strands=0,this._strands=[],this._nucleotide_to_strand=[],this.E_pot=s,this.E_kin=n,this.E_tot=s+n,this.isDNA=!0,m.index=0,b.index=0}get sequences(){return this._strands.map((t=>t._sequence))}get N(){return this._N}get N_strands(){return this._N_strands}_prepare(){let t=0;for(let e=0;e<this._N_strands;e++)t=this._strands[e]._prepare(e,t);for(const t of this._strands)t.bring_in_box_nucleotides(this._box)}copy(){let t=new y(this._box);for(const e of this._strands)t.add_strand(e.copy());return t}join(e,s){if(void 0===s){s=new t.Vector3(0,0,0);for(let t=0;t<3;t++)e._box[t]>this._box[t]?s[t]=e._box[t]:s[t]=this._box[t]}let n=new y(s);for(const t of this._strands)n.add_strand(t.copy());for(const t of e._strands)n.add_strand(t.copy());return n}add_strand(t){return this._strands.push(t),this._N+=t.N,this._N_strands++,!0}add_strands(t){if(Array.isArray(t)){let e=[];for(const s of t)this.add_strand(s)&&e.push(s);if(e.length===t.length)return!0;for(const t of e)m.index-=t.N,b.index--,this._strands.pop(),this._N-=t.N,this._N_strands--;return!1}return!!this.add_strand(t)}rotate(t,e){for(const s of this._strands)s.rotate(t,e)}translate(t){for(const e of this._strands)e.translate(t)}print_lorenzo_output(){let t=`t = ${this._time}\nb = ${this._box.x} ${this._box.y} ${this._box.z}\nE = ${this.E_tot} ${this.E_pot} ${this.E_kin}\n`,e=0,s=0;for(const t of this._strands)e++,s+=t.N;let n=`${s} ${e}\n`;for(const e of this._strands){let[s,o]=e._get_lorenzo_output();n+=o,t+=s}return[n,t]}print_oxview_output(){let t={box:this._box.round().toArray(),systems:[{id:0,strands:[]}]};for(const e of this._strands){let s={id:e.index,end3:e._nucleotides[0].index,end5:e._nucleotides.slice(-1)[0].index,class:"NucleicAcidStrand",monomers:[]};for(let t=0;t<e.N;t++){let n,o,i=e._nucleotides[t];e._circular?(o=0===t?e._nucleotides.slice(-1)[0].index:e._nucleotides[t-1].index,n=t===e._nucleotides.length-1?e._nucleotides[0].index:e._nucleotides[t+1].index):(o=0===t?-1:e._nucleotides[t-1].index,n=t===e._nucleotides.length-1?-1:e._nucleotides[t+1].index);let a={id:i.index,type:i.get_base(),class:this.isDNA?"DNA":"RNA",p:i.cm_pos.toArray(),a1:i._a1.toArray(),a3:i._a3.toArray()};o>=0&&(a.n3=o),n>=0&&(a.n5=n),void 0!==i.pair&&(a.bp=i.pair.index),void 0!==i.cluster&&(a.cluster=i.cluster),void 0!==i.color&&(a.color=i.color),s.monomers.push(a)}t.systems[0].strands.push(s)}return JSON.stringify(t)}get _nucleotides(){return[].concat(...this._strands.map((t=>t._nucleotides)))}map_nucleotides_to_strands(){for(let t=0;t<this._strands.length;t++)for(let e=0;e<this._strands[t].N;e++)this._nucleotide_to_strand.push(t)}print_dot_bracket_output(){let t="";for(let e=0;e<this.N;e++){let s=this._nucleotides[e].interactions;s.length>1&&g.log("more than 1 HB for a nucleotide",g.WARNING),0===s.length?t+=".":s[0]>e?t+="(":s[0]<e?t+=")":g.log("unexpected interaction detected while building nupack string",g.CRITICAL)}return t}calc_clusters(t=1.0018){let e=new Set,s=new Map,n=new Map,o=(e,s)=>{let n=e.distance(s,!1);return Math.sqrt(n.dot(n))>t};for(const t of this._strands){const i=t.N;for(let a=0;a<i-1;a++){const i=t._nucleotides[a],r=t._nucleotides[a+1];s.set(r,i),n.set(i,r),o(i,r)&&(e.add(i),e.add(r))}}let i=t=>{const e=[];void 0!==t.pair&&e.push(t.pair);let o=s.get(t),i=n.get(t);return void 0!==o&&e.push(o),void 0!==i&&e.push(i),e},a=(t,e)=>{const s=Math.min(t,e);for(const n of this._strands)for(const o of n._nucleotides)o.cluster!==t&&o.cluster!==e||(o.cluster=s)},r=t=>{let s=[t];for(;s.length>0;){let t=s.pop();const n=i(t);for(const o of n)o.cluster!==t.cluster&&(void 0===o.cluster?(o.cluster=t.cluster,s.push(o)):e.has(t)&&e.has(o)||a(t.cluster,o.cluster))}},l=1;for(const t of e)t.cluster=l++;for(const t of e)r(t);if(0===e.size)for(const t of this._strands)for(const e of t._nucleotides)e.cluster=1}}class w{generate(e,s,n=new t.Vector3(0,0,0),o=new t.Vector3(0,0,1),i,a=0,r=!0,l=!1,c=0,d=10.34,h,_,y=!1){if("string"==typeof s)try{s=Array.from(s).map((t=>u[t])),g.log("We have a sequence already",g.WARNING)}catch(t){g.die("Key Error: sequence is invalid")}if(void 0===s){s=new Array(e);for(let t=0;t<e;t++)g.log("No sequence info, adding Thymine!",g.WARNING),s[t]=u.T}else if(s.length!=e){let t=e-s.length;for(g.log(`sequence is too short, adding ${t} thymine bases`,g.WARNING);t--;)s.push(u.T)}l&&e<30&&g.log("sequence is too short! Proceed at your own risk",g.WARNING);let w=!0;l&&e<30&&!r&&(g.log("sequence is too short! Generating ssDNA without imposed helicity",g.WARNING),y||(w=!1)),void 0===h&&(h=0),void 0===_&&(_=e),h>_&&g.die("ds_end > ds_start"),_>e&&g.die("ds_end > bp");let x,N=Math.sqrt(o.dot(o));N<1e-10?(g.log("direction must be a valid vector, defaulting to (0, 0, 1)",g.WARNING),o=new t.Vector3(0,0,1)):o.divideScalar(N),i?x=i:(x=new t.Vector3(Math.random(),Math.random(),Math.random()),x.sub(o.clone().multiplyScalar(o.clone().dot(x))),x.normalize());let M,v,A,I=new b,V=x.clone().applyAxisAngle(o,a),$=n.clone(),S=o;if(l&&(M=x.clone().cross(o),v=2*Math.PI/e,A=.7525/Math.sqrt(2*(1-Math.cos(v)))),l&&w){for(let t=0;t<e;t++){let n=x.clone().multiplyScalar(f*Math.cos(t*v)).add(o.clone().multiplyScalar(f*Math.sin(t*v)));$.add(n),S=n.clone().normalize(),V=S.clone().cross(M),V.applyAxisAngle(S,t*(Math.round(Math.floor(e/d))+c)/e*2*Math.PI),I.add_nucleotide(new m($.clone().sub(V.clone().multiplyScalar(p)),V,S,s[t]))}I.make_circular(!0)}else if(l&&!w){for(let n=0;n<e;n++)$=new t.Vector3(Math.cos(n*v)*A+.34*Math.cos(n*v),Math.sin(n*v)*A+.34*Math.sin(n*v),0),V=new t.Vector3(Math.cos(n*v),Math.sin(n*v),0),I.add_nucleotide(new m($,V,new t.Vector3(0,0,1),s[n]));I.make_circular(!0)}else for(let t=0;t<e;t++)I.add_nucleotide(new m($.clone().sub(V.clone().multiplyScalar(p)),V,S,s[t])),t!=e-1&&(V.applyAxisAngle(o,35.9*Math.PI/180),$.add(S.multiplyScalar(f)));if(r){let t=new b;for(let e=_-1;e<=h;e--){let n=I._nucleotides[e];V=n._a1.clone().negate(),S=n._a3.clone().negate();let o=V.clone().multiplyScalar(-1.2).add(n.cm_pos);t.add_nucleotide(new m(o,V,S,3-s[e]))}return 0===h&&_===e&&l&&t.make_circular(!0),[I,t]}return I}generate_or_sq(e,s=new t.Vector3(0,0,0),n=new t.Vector3(0,0,1),o,i=!0,a=0,r=Math.PI/180*33.75,l=[],c=[],d=[]){if(l&&c.length!=d.length&&(d.length+1===c.length?(g.log(`the lengths of begin ${c.length} and end ${d.length} arrays are mismatched; I will try to proceed by using the number of basepairs as the last element of the end array`,g.WARNING),d.push(e+1)):g.die(`the lengths of begin ${c.length} and end ${d.length} arrays are unrecoverably mismatched`)),Array.isArray(r))r.length!=e-1&&g.log("generate_or_sq: incorrect angle array length, should be 1 less than number of base pairs",g.CRITICAL);else{let t=r;r=[];for(let s=0;s<e;s++)r.push(t)}let h,u=Math.sqrt(n.dot(n));u<1e-10?(g.log("direction must be a valid vector, defaulting to (0, 0, 1)",g.WARNING),n=new t.Vector3(0,0,1)):n.divideScalar(u),void 0===o?(h=new t.Vector3(Math.random(),Math.random(),Math.random()),h.sub(n.clone().multiplyScalar(n.clone().dot(h))),h.normalize()):h=o.clone();let _=new b,y=h.clone().applyAxisAngle(n,a),w=s.clone(),x=n.clone(),N=[];for(let s=0;s<e;s++)if(_.add_nucleotide(new m(w.clone().sub(y.clone().multiplyScalar(p)),y.clone(),x.clone(),void 0)),s!=e-1){let e=(new t.Quaternion).setFromAxisAngle(n,r[s]);if(N.push(e),y.applyQuaternion(e).normalize(),w.add(x.clone().normalize().multiplyScalar(f)),l)for(let t=0;t<l.length;t++)s>=c[t]&&s<d[t]&&l[t]&&w.add(x.clone().multiplyScalar(f*(-l[t]/(d[t]-c[t]))))}if(i){y.negate().normalize(),x=n.clone().negate().normalize();let t=new b;for(let s=0;s<e;s++){let n=_._nucleotides[e-s-1],o=new m(w.clone().sub(y.clone().multiplyScalar(p)),y.clone(),x.clone(),void 0,void 0,void 0,void 0,n);if(n.pair=o,t.add_nucleotide(o),s!=e-1&&(y.applyQuaternion(N.pop().conjugate()).normalize(),w.add(x.clone().multiplyScalar(f)),l))for(let t=0;t<l.length;t++)e-2-s>=c[t]&&e-2-s<d[t]&&l[t]&&w.add(x.clone().multiplyScalar(f*(-l[t]/(d[t]-c[t]))))}return[_,t]}return _}generate_double_offset(e,s,n,o=new t.Vector3(0,0,0),i=new t.Vector3(0,0,1),a,r=0){let l,c;l="string"==typeof e?[...e].map((t=>u[t])):e,c="string"==typeof s?[...s].map((t=>u[t])):s;let d=Math.max(l.length,c.length+n),h=this.generate(d,void 0,o,i,!1,void 0,!0),_=h[0],p=h[1];return _=_.get_slice(0,l.length),p=c.length+n>l.length?p.get_slice(0,c.length):p.get_slice(d-n-c.length,c.length),_.sequence=l,p.sequence=c,[_,p]}generate_rw(e,s=new t.Vector3(0,0,0)){g.log("Generating strand as a random walk. Remember to equilibrate the configuration with MC",g.WARNING);let n=new t.Vector3(.7525,0,0),o=s,i=[];i.push(o);for(let t=1;t<e.length;t++){let t,e=!0;for(;e;){e=!1;let s=d(),a=n.clone().applyMatrix3(s);t=o.clone().add(n.clone().applyMatrix3(s)),e=!1;for(const s of i)a=t.clone().sub(s),a.dot(a)<.4*.4&&(e=!0)}o=t,i.push(o)}let a=[];n=i[1].clone().sub(i[0]),a.push(n.clone().divideScalar(Math.sqrt(n.dot(n))));for(let t=1;t<i.length-1;t++)n=i[t+1].clone().add(i[t-1]).multiplyScalar(.5),n=i[t].clone().sub(n),a.push(n.clone().divideScalar(Math.sqrt(n.dot(n))));n=i[i.length-1].clone().sub(i[i.length-2]),a.push(n.divideScalar(Math.sqrt(n.dot(n))));let r=new b;for(let t=0;t<i.length;t++){let s=i[t],[n,o,d]=l(a[t],c(),c()),h=s+a[t]*Math.abs(-.4);r.add_nucleotide(new m(h,n,d,e[t]))}return r}}class x{constructor(){this.map=new Map}set(t,e){this.map.set(t.toString(),e)}get(t){return this.map.get(t.toString())}has(t){return this.map.has(t.toString())}get size(){return this.map.size}*keys(){for(let t of this.map.keys())yield t.split(",").map((t=>parseInt(t)))}*entries(){for(let[t,e]of this.map.entries()){let s=t.split(",").map((t=>parseInt(t)));yield[s,e]}}values(){return this.map.values()}}class N extends x{constructor(){super(),this._scaf=new x,this._stap=new x,this.nuc_count=0,this.strand_count=0}add_scaf(t,e,s,n){this._scaf.set([t,e],[s,n])}add_stap(t,e,s,n){this._stap.set([t,e],[s,n])}add_scaf_strand(t,e,s=!1){let n=0;const o=this._scaf.size;for(const[[s,o],[i,a]]of e._scaf.entries())i===t&&(this.add_scaf(s,o,this.strand_count,a.map((t=>t+this.nuc_count))),n+=a.length);return this.nuc_count+=n,this._scaf.size===o?1:(s||this.strand_count++,0)}add_stap_strand(t,e,s=!1){let n=0;const o=this._stap.size;for(const[[s,o],[i,a]]of e._stap.entries())i===t&&(this.add_stap(s,o,this.strand_count,a.map((t=>t+this.nuc_count))),n+=a.length);return this.nuc_count+=n,this._stap.size===o?1:(s||this.strand_count++,0)}add_strand(t,e,s=!1){return this.add_scaf_strand(t,e,s)&&this.add_stap_strand(t,e,s)}}const M=2.55,v=2.6;class A{constructor(){this.begin=[],this.end=[]}toString(){return`${this.begin} ${this.end}`}add_begin(t){this.begin.includes(t)||this.begin.push(t)}add_end(t){this.end.includes(t)||this.end.push(t)}}function I(t,s,n,o,i,a,r,l,c,d,h,u){let _,p,f=0,g=0;if((s.num%2+u)%2==0){for(const t of s.skip.slice(0,n))f-=t;for(const t of s.skip.slice(0,o+1))g-=t;for(const t of s.loop.slice(0,n))f+=t;for(const t of s.loop.slice(0,o+1))g+=t;_=n+f,p=o+1+g}else{for(const t of s.skip.slice(o))g-=t;for(const t of s.skip.slice(n+1))f-=t;for(const t of s.loop.slice(o))g+=t;for(const t of s.loop.slice(n+1))f+=t;_=s.len-n-1+f,p=s.len-o+g}let m=function(t,s,n,o,i,a,r){let l,c=[],d=0,h=new A,u=[],_=i.slice();a.num%2==1&&(l=new A,l.begin=r.begin.slice().reverse(),l.end=r.end.slice().reverse());for(let t=0;t<r.begin.length;t++){let s,n,o,p;if(a.num%2==0?(s=r.begin[t],p=r.end[t],n=r.begin[t],o=r.end[t]):(s=l.end[t],p=l.begin[t],n=a.len-l.begin[t]-1,o=a.len-l.end[t]-1),o-n!=0){c.push(0);for(const e of a.skip.slice(s,p+1))c[t]-=e;for(const e of a.loop.slice(s,p+1))c[t]+=e;u.push(e(...i.slice(n,o))/(o-n+c[t]));for(let e=n;e<o;e++)_[e]=u[t];n+=d,o+=d+c[t],h.add_begin(n),h.add_end(o)}else c.push(0),u.push(e(...i)/i.length),n+=d,o+=d+c[t],h.add_begin(n),h.add_end(o);d+=c[t]}let p=0,f=0,g=0,m=0;for(let t=0;t<r.begin.length;t++){let e,s,n,o;p+=g,f+=m,g=0,m=0,a.num%2==0?(e=r.begin[t],s=r.end[t],n=r.begin[t],o=r.end[t]):(e=l.end[t],s=l.begin[t],n=a.len-l.begin[t]-1,o=a.len-l.end[t]-1);for(const t of a.skip.slice(e,s+1))1===t&&(_.splice(n-p+f,1),g++);for(const o of a.loop.slice(e,s+1))for(let e=0;e<o;e++)_.splice(n-p+f,0,u[t]),m++}return(new w).generate_or_sq(_.length+1,t,s,n,!0,o,_,c,h.begin,h.end)}(r,l,c,d,h,s,i);return t.add_strand(m[u].get_slice(_,p)),t}function V(t,e,n,o,i,a){let r,l=0,c=0,d=0;if((t.num%2+a)%2==0){for(const e of t.skip.slice(n,o+1))l-=e;for(const e of t.loop.slice(n,o+1))l+=e}else{for(const e of t.skip.slice(o,n+1))l-=e;for(const e of t.loop.slice(o,n+1))l+=e}r=(a+t.num%2)%2==0?o-n+1+l:n+1-o+l;let h=0;for(;h<r;){let o;if(o=(a+t.num%2)%2==0?h+n+c-d:n-h-c+d,1!=t.skip[o]){let n;n=(a+t.num%2)%2==0?s(t.loop[o]+1).map((t=>h+t)):s(t.loop[o]+1).reverse().map((t=>h+t)),0===a?i.set([t.num,o],[e,[h]]):1===a?i.set([e,h],[t.num,[o]]):2===a?i.add_scaf(t.num,o,e,n):3===a&&i.add_stap(t.num,o,e,n),h+=1+t.loop[o],d+=t.loop[o]}else 2===a?i.add_scaf(t.num,o,e,[]):3===a&&i.add_stap(t.num,o,e,[]),c++}return i}function $(t){let e=new A,n=-1;t.num%2==0&&(n=1);for(let o=0;o<t.scaf.length;o++){let i,a,r,l,c=o-1*n,d=o+1*n;s(t.scaf.length).includes(c)?(i=t.scaf[c].type(t,c),a=t.stap[c].type(t,c)):(i=!1,a=!1),s(t.scaf.length).includes(d)?(r=t.scaf[d].type(t,d),l=t.stap[d].type(t,d)):(r=!1,l=!1),(i!==a||"begin"!==i&&"end"!==i)&&(r!==l||"begin"!==r&&"end"!==r)&&("empty"===t.scaf[o].type(t,o)?"begin"===t.stap[o].type(t,o)?e.add_end(o):"end"===t.stap[o].type(t,o)&&e.add_begin(o):"begin"===t.scaf[o].type(t,o)?"empty"===t.stap[o].type(t,o)?e.add_begin(o):"continue"===t.stap[o].type(t,o)?(e.add_begin(o),e.add_end(o-1*n)):"begin"===t.stap[o].type(t,o)?(e.add_begin(o+1*n),e.add_end(o-1*n)):"end"===t.stap[o].type(t,o)&&e.add_begin(o):"end"===t.scaf[o].type(t,o)?"empty"===t.stap[o].type(t,o)?e.add_end(o):"continue"===t.stap[o].type(t,o)?(e.add_begin(o+1*n),e.add_end(o)):"begin"===t.stap[o].type(t,o)?e.add_end(o):"end"===t.stap[o].type(t,o)&&(e.add_begin(o+1*n),e.add_end(o-1*n)):"continue"===t.scaf[o].type(t,o)&&("begin"===t.stap[o].type(t,o)?(e.add_begin(o+1*n),e.add_end(o)):"end"===t.stap[o].type(t,o)&&(e.add_begin(o),e.add_end(o-1*n))))}return e}function S(s,n,o){let i=new w,a=new Array(o.len-1);for(let t=0;t<a.length;t++){let e=t%32;e<2?a[t]=28*Math.PI/180:2===e?a[t]=36*Math.PI/180:3===e?a[t]=54.375*Math.PI/180:4===e?a[t]=37*Math.PI/180:[5,6].includes(e)?a[t]=27.6666666666666*Math.PI/180:7===e?a[t]=30.6666666666666*Math.PI/180:[8,9].includes(e)?a[t]=29.3333333333*Math.PI/180:10===e?a[t]=34.3333333333*Math.PI/180:11===e?a[t]=54.5*Math.PI/180:[12,13].includes(e)?a[t]=28.91666666666*Math.PI/180:[14,15,16,17].includes(e)?a[t]=31.16666666666*Math.PI/180:18===e?a[t]=35.5*Math.PI/180:19===e?a[t]=52*Math.PI/180:20===e?a[t]=35.5*Math.PI/180:[21,22].includes(e)?a[t]=27.5*Math.PI/180:a[t]=23===e?35.5*Math.PI/180:e>=24&&e<27?30*Math.PI/180:27===e?52*Math.PI/180:28===e?35.5*Math.PI/180:Math.PI/180*30.91666666666}let r,l,c,d,h,u=0;for(let t=0;t<31;t++)u+=a[t];for(let t=0;t<a.length;t++)t%32==31&&(a[t]=1080*Math.PI/180-u);return o.num%2==0?(r=new t.Vector3(o.col*v,o.row*v,0),l=s.clone(),c=n.clone(),d=0,h=a.slice()):(r=new t.Vector3(o.col*v,o.row*v,(o.len-1)*f),l=s.clone().negate(),c=n.clone().negate(),d=-e(...a)%(2*Math.PI),h=a.slice().reverse()),[i.generate_or_sq(o.len,r,l,c,!0,d,h),a,r,d,l,c]}function q(s,n,o){let i=new w,a=new Array(o.len-1);for(let t=0;t<a.length;t++){const e=t%21;0===e?a[t]=32.571*Math.PI/180:1===e?a[t]=36*Math.PI/180:[1,2,3].includes(e)?a[t]=42*Math.PI/180:[5,6,7].includes(e)?a[t]=29.143*Math.PI/180:8===e?a[t]=32*Math.PI/180:[9,10].includes(e)?a[t]=44*Math.PI/180:[12,13,14].includes(e)?a[t]=28.571*Math.PI/180:[16,17].includes(e)?a[t]=41.5*Math.PI/180:[19,20].includes(e)?a[t]=28.476*Math.PI/180:a[t]=720/21*(Math.PI/180)}let r,l,c,d,h,u=0;for(let t=0;t<20;t++)u+=a[t];for(let t=0;t<a.length;t++)t%21==20&&(a[t]=720*Math.PI/180-u);if(o.num%2==0)r=new t.Vector3(o.col*Math.sqrt(3)*M/2,3*o.row*M/2,0),l=s.clone(),c=n.clone(),d=0,h=i.generate_or_sq(o.len,r,l,c,!0,d,a);else{r=new t.Vector3(o.col*Math.sqrt(3)*M/2,3*o.row*M/2+1.275,(o.len-1)*f),l=s.clone().negate(),c=n.clone().negate(),d=-e(...a)%(2*Math.PI);let u=a.slice().reverse();h=i.generate_or_sq(o.len,r,l,c,!0,d,u)}return[h,a,r,d,l,c]}class k{constructor(){this.vhelices=[]}add_vhelix(t){this.vhelices.push(t)}bbox(){let t=[],e=[],s=[];for(const n of this.vhelices)t.push(n.row),e.push(n.col),s.push(n.stap.length);const n=v*(Math.max(...t)-Math.min(...t)+2),o=v*(Math.max(...e)-Math.min(...e)+2),i=.34*(Math.max(...s)+2);return 2*Math.max(n,o,i)*2}toString(){let t='{\n"vstrands":[\n';if(this.vhelices.length>0){for(const e of this.vhelices)t+=`${e},`;t=t.slice(0,t.length-1)}return t+="}\n",t}}class P{constructor(){this.stapLoop=[],this.scafLoop=[],this.skip=[],this.loop=[],this.stap_colors=[],this.row=0,this.col=0,this.num=0,this.stap=[],this.scaf=[],this.cad_index=-1,this.skiploop_bases=0}get len(){return Math.max(this.scaf.length,this.stap.length)}add_square(t,e){"stap"===e?this.stap.push(t):"scaf"===e?this.scaf.push(t):g.log("Cannot add square that is not scaf or stap. Dying now",g.CRITICAL)}toString(){let t="{\n";if(t+='"stapLoop":[',this.stapLoop.length>0){for(const e of this.stapLoop)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"skip":[',this.skip.length>0){for(const e of this.skip)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"loop":[',this.loop.length>0){for(const e of this.loop)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"stap_colors":[',this.stap_colors.length>0){for(const e of this.stap_colors)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+=`"row":${this.row},\n`,t+=`"col":${this.col},\n`,t+=`"num":${this.num},\n`,t+='"scafLoop":[',this.scafLoop.length>0){for(const e of this.scafLoop)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"stap":[',this.stap.length>0){for(const e of this.stap)t+=`${e},`;t=t.slice(0,t.length-1)}if(t+="],\n",t+='"scaf":[',this.scaf.length>0){for(const e of this.scaf)t+=`${e},`;t=t.slice(0,t.length-1)}return t+="]\n}",t}}class C{constructor(t=-1,e=-1,s=-1,n=-1){this.V_0=t,this.b_0=e,this.V_1=s,this.b_1=n}toString(){return`[${this.V_0},${this.b_0},${this.V_1},${this.b_1}]`}type(t,e){if(-1===this.V_0&&-1===this.b_0){if(-1===this.V_1&&-1===this.b_1)return"empty";if(this.V_1===t.num&&1===Math.abs(this.b_1-e))return"begin"}else{if(this.V_0===t.num&&1===Math.abs(this.b_0-e))return-1===this.V_1?"end":this.V_1===t.num&&1===Math.abs(this.b_1-e)?"continue":"end";if(this.V_1===t.num&&1===Math.abs(this.b_1-e))return"begin"}g.log("unexpected square array",g.WARNING)}}function G(t,e,s){let n=.4*parseFloat(s)/2;return t.clone().sub(e.clone().multiplyScalar(n))}class R{constructor(e,s=!0,n,o="R"){this.id=e.id,this.isDNA=s,this.tiamat_version_fudge=n;try{this.val=u[e.type[0]]}catch(t){const e=["A","C","G",s?"T":"U"];"R"==o?this.val=i(0,4):(this.val=u[o],console.assert(void 0!==this.val,`Default base ${o} not supported, use one of ${e}`)),g.log(`WARNING: base n.${this.id} has no associated type, setting it to '${e[this.val]}'`)}this.tiamat_pos=(new t.Vector3).fromArray(e.position),this.tiamat_pos.multiplyScalar(R.scale),this.obj=e}getNeighborId(t){let e=this.obj[t];return void 0===e&&(e=-1),e}getNeighbor(t,...e){let s=this;for(const n of e)if(s=t.get(s.obj[n]),void 0===s)break;return s}hasNeighbor(t,...e){return void 0!==this.getNeighbor(t,...e)}getNeighborPos(e,...s){let n,o=this.getNeighbor(e,...s);return n=void 0===o?new t.Vector3(0,0,1).multiplyScalar(R.scale):o.tiamat_pos,n}set_base_config(e){let s=this.tiamat_pos,n=this.getNeighborPos(e,"across"),o=this.getNeighborPos(e,"up"),i=this.getNeighborPos(e,"down"),a=this.getNeighborPos(e,"up","across"),r=this.getNeighborPos(e,"down","across"),l=n.clone().sub(s).normalize(),c=o.clone().sub(s).normalize(),d=i.clone().sub(s).normalize(),h=a.clone().sub(s).normalize(),u=r.clone().sub(s).normalize();this.hasNeighbor(e,"down","across")?(this.isDNA?[this.a1,this.a3,this.cm_pos]=z(l,d,u,-.13079674,-.22543211,.62949112,2.69498211,-1.04531113,-2.30531223):[this.a1,this.a3,this.cm_pos]=z(l,d,u,-.28102082,-.25891019,.84990909,2.34763359,-1.1627428,-1.63537381),this.cm_pos.add(s.clone().multiplyScalar(this.tiamat_version_fudge))):this.hasNeighbor(e,"up","across")?(this.isDNA?[this.a1,this.a3,this.cm_pos]=function(t,e,s){return z(t,e,s,.81079674,.22543211,-.50262804,-2.12846367,.82557385,2.33064701)}(l,c,h):[this.a1,this.a3,this.cm_pos]=function(t,e,s){return z(t,e,s,.85540635,.30569283,-.44567833,-1.60523423,.58820649,2.00150202)}(l,c,h),this.cm_pos.add(s.clone().multiplyScalar(this.tiamat_version_fudge))):(this.cm_pos=s,this.a3=new t.Vector3(0,0,1),this.a1=new t.Vector3(0,1,0))}}function z(t,e,s,n,o,i,a,r,l){let c=(n,o,i)=>t.clone().multiplyScalar(n).add(e.clone().multiplyScalar(o).add(s.clone().multiplyScalar(i))).normalize();const d=c(n,o,i),h=c(a,r,l);return[t.clone(),h,d]}R.scale=1/.85;const W=1/8.518,T=new Map([["ADE","A"],["CYT","C"],["GUA","G"],["THY","T"],["URA","U"]]),E=["A","T","G","C","U"];let O=!1;class j{constructor(t,e){this.name=t.trim(),[...T.keys()].includes(this.name)?this.base=T[this.name]:this.name in E?("U"!=this.name||O||(g.log("WARNING: unsupported uracil detected: use at your own risk"),O=!0),this.base=this.name):this.base=t.slice(1),this.idx=e,this.base_atoms=[],this.phosphate_atoms=[],this.sugar_atoms=[],this.named_atoms={},this.ring_names=["C2","C4","C5","C6","N1","N3"]}get atoms(){return[].concat(this.base_atoms,this.phosphate_atoms,this.sugar_atoms)}add_atom(t){t.name.includes("P")||"HO5'"==t.name?this.phosphate_atoms.push(t):t.name.includes("'")?this.sugar_atoms.push(t):this.base_atoms.push(t),this.named_atoms[t.name]=t,void 0===this.chain_id&&(this.chain_id=t.chain_id)}get_com(e){null==e&&(e=this.atoms);let s=new t.Vector3(0,0,0);for(const t of e)s.add(t.pos);return s.divideScalar(e.length)}compute_a3(){const e=this.get_com(this.base_atoms),n=this.named_atoms["O4'"].pos.clone().sub(e);this.a3=new t.Vector3(0,0,0);for(const t of function*(t,e){let n=Array.from(t),o=n.length;if(3>o)return;let i=Array.from(s(o)),a=Array.from(s(o,o-3,-1)),r=t=>n[t];for(yield i.slice(0,3).map(r);o>0;){let t=!0;for(let e of s(2,-1,-1)){if(a[e]-=1,0!==a[e]){let s=a[e],[n,o]=[i[i.length-s],i[e]];i[e]=n,i[i.length-s]=o,yield i.slice(0,3).map(r),t=!1;break}i=i.slice(0,e).concat(i.slice(e+1)).concat(i.slice(e,e+1)),a[e]=o-e}if(t)return}}(this.ring_names)){let e=this.named_atoms[t[0]],s=this.named_atoms[t[1]],o=this.named_atoms[t[2]],i=e.pos.clone().sub(s.pos),a=e.pos.clone().sub(o.pos);if(i.divideScalar(Math.sqrt(i.dot(i))),a.divideScalar(Math.sqrt(a.dot(a))),Math.abs(i.dot(a))>.01){let t=i.clone().cross(a);t.divideScalar(Math.sqrt(t.dot(t))),t.dot(n)<0&&t.negate(),this.a3.add(t)}}this.a3.divideScalar(Math.sqrt(this.a3.dot(this.a3)))}compute_a1(){let e;e=this.name.includes("C")||this.name.includes("T")||this.name.includes("U")?[["N3","C6"],["C2","N1"],["C4","C5"]]:[["N1","C4"],["C2","N3"],["C6","C5"]],this.a1=new t.Vector3(0,0,0);for(const t of e){let e=this.named_atoms[t[0]],s=this.named_atoms[t[1]],n=e.pos.clone().sub(s.pos);this.a1.add(n)}this.a1.divideScalar(Math.sqrt(this.a1.dot(this.a1)))}compute_as(){this.compute_a1(),this.compute_a3(),this.a2=this.a3.clone().cross(this.a1),this.check=Math.abs(this.a1.dot(this.a3))}correct_for_large_boxes(t){for(const s of this.atoms)s.shift((e=s.pos/t,-Math.sign(e)*Math.round(Math.abs(e))*t));var e}to_pdb(t,e,s,n,o){let i,a,r,l,c=[];for(const l of this.atoms)if(e||!l.name.includes("H")){if("5"==o){if("P"in l.name){"P"==l.name&&(i=l);continue}"O5'"==l.name&&(a=l)}else"3"==o&&"O3'"==l.name&&(r=l);c.push(l.to_pdb(t,s,n))}if("5"==o){let e=i.clone();e.name="HO5'";let o=i.pos.sub(l.pos);o.multiplyScalar(1/Math.sqrt(o.dot(o))),e.pos=l.pos.clone().add(o),c.push(e.to_pdb(t,s,n))}else if("3"==o){let e=r.clone();e.name="HO3'";let o=this.a2.clone().multiplyScalar(.2).sub(this.a1.clone().multiplyScalar(.2)).sub(this.a3);o.multiplyScalar(1/Math.sqrt(o.dot(o))),e.pos=r.pos.clone().add(o),c.push(e.to_pdb(t,s,n))}return c.join("\n")}to_mgl(){let t=[];for(const e of this.atoms)t.push(e.to_mgl());return t.join("\n")}rotate(t){let e=this.get_com();for(const s of this.atoms)s.pos=t.dot(s.pos.clone().sub(e)).add(e);this.compute_as()}set_com(t){let e=this.get_com();for(const s of this.atoms)s.pos.add(t.sub(e).sub(this.a1.clone().multiplyScalar(.5)))}}class D{constructor(e){this.name=e.slice(12,16).trim(),this.name.includes("*")&&(this.name=this.name.replace("*","'")),this.alternate=e[16],this.residue=e.slice(17,20).trim(),this.chain_id=e.slice(21,22).trim(),this.residue_idx=parseInt(e.slice(22,26)),this.pos=new t.Vector3(parseFloat(e.slice(30,38)),parseFloat(e.slice(38,46)),parseFloat(e.slice(46,54)))}clone(){let t=new D("");return t.name=this.name.slice(),t.alternate=this.alternate.slice(),t.residue=this.residue.slice(),t.chain_id=this.chain_id.slice(),t.residue_idx=this.residue_idx,t.pos=this.pos.clone(),t}is_hydrogen(){this.name.includes("H")}shift(t){this.pos.add(t)}to_pdb(t,e,s){let n=this.residue+s,o=(t,e)=>`${t}`.padStart(e," "),i=`ATOM  ${o(D.serial_atom,5)} ${o(this.name,4)} ${o(n,3)} ${o(t,3)}${o(e,1)}    ${o(this.pos.x.toFixed(3),8)}${o(this.pos.y.toFixed(3),8)}${o(this.pos.z.toFixed(3),8)}  1.00  0.00              `;return D.serial_atom++,D.serial_atom>99999&&(D.serial_atom=1),i}}function F(n,o,l,c){let d;switch(o){case"cadnano":d=function(n,o,l,c,d="N"){let h=!1,_=!1;if("sq"===o)h=!0;else{if("he"!==o)return void alert("Lattice_type should be either 'sq' or 'he'");_=!0}let p=new N,f=new N,w=function(t){let s=new k,n=JSON.parse(t);for(const t of n.vstrands){let n=new P;for(const[e,s]of Object.entries(t))"skip"===e?n.skip=s.map((t=>Math.abs(t))):n[e]="stap"===e||"scaf"===e?s.map((t=>new C(...t))):s;n.skiploop_bases=n.skip.length+e(...n.loop)-e(...n.skip),s.add_vhelix(n)}return s}(n),M=0;void 0===c&&(c=w.bbox(),g.log("Using default box size, a factor 2 larger than the size of the cadnano system",g.INFO));let v=new t.Vector3(0,0,1),A=new t.Vector3(1,0,0);var G;h?(G=v,A=A.clone().applyAxisAngle(G,15*Math.PI/180)):_&&(A=function(t,e){return e.clone().applyAxisAngle(t,160*Math.PI/180)}(v,A));let R=new y(new t.Vector3(c,c,c)),z=new y(new t.Vector3(c,c,c)),W=-1,T=[],E=[],O=!1,j=[],D=[],F=-1,L=-1;for(const t of w.vhelices){let e,s,n,o,i,a;t.cad_index=M,h?[e,s,n,o,i,a]=S(v,A,t):_&&([e,s,n,o,i,a]=q(v,A,t));let l=$(t),c=0;for(const e of t.scaf){if(-1===e.V_0&&-1===e.b_0)-1===e.V_1&&-1===e.b_0||(e.V_1===t.num&&1===Math.abs(e.b_1-c)?(t.num%2==0&&W++,F=c,t.num%2==1&&(R=I(R,t,F,L,l,0,n,i,a,o,s,0),p=V(t,W,F,L,p,2))):g.log("unexpected square array",g.WARNING));else if(e.V_0===t.num&&1===Math.abs(e.b_0-c))if(-1===e.V_1&&-1===e.b_1)t.num%2==1&&W++,L=c,t.num%2==0&&(R=I(R,t,F,L,l,0,n,i,a,o,s,0),p=V(t,W,F,L,p,2));else if(e.V_1===t.num&&1===Math.abs(e.b_1-c));else{let d;t.num%2==1&&W++,L=c,t.num%2==0&&(R=I(R,t,F,L,l,0,n,i,a,o,s,0),p=V(t,W,F,L,p,2)),t.num,d=c;for(let e=0;e<T.length;e++)r([t.num,d],T[e])&&(j[e].splice(0,0,W),O=!0);O||(j.push([W]),T.push([e.V_1,e.b_1])),O=!1}else if(-1===e.V_1&&-1===e.b_1)g.log("unexpected square array",g.WARNING);else if(e.V_1===t.num&&1===Math.abs(e.b_1-c)){t.num%2==0&&W++,F=c,t.num%2==1&&(R=I(R,t,F,L,l,0,n,i,a,o,s,0),p=V(t,W,F,L,p,2));for(let e=0;e<T.length;e++){let s;t.num,s=c,r([t.num,s],T[e])&&(j[e].push(W),O=!0)}O||(j.push([W]),T.push([e.V_0,e.b_0])),O=!1}else g.log("unexpected square array",g.WARNING);c++}if(0!==R.N_strands){c=0;for(const e of t.stap){if(-1===e.V_0&&-1===e.b_0)-1===e.V_1&&-1===e.b_0||(e.V_1===t.num&&1===Math.abs(e.b_1-c)?(t.num%2==1&&W++,F=c,t.num%2==0&&(R=I(R,t,F,L,l,0,n,i,a,o,s,1),p=V(t,W,F,L,p,3))):g.log("unexpected square array",g.WARNING));else if(e.V_0===t.num&&1===Math.abs(e.b_0-c))if(-1===e.V_1&&-1===e.b_1)t.num%2==0&&W++,L=c,t.num%2==1&&(R=I(R,t,F,L,l,0,n,i,a,o,s,1),p=V(t,W,F,L,p,3));else if(e.V_1===t.num&&1===Math.abs(e.b_1-c));else{t.num%2==0&&W++,L=c,t.num%2==1&&(R=I(R,t,F,L,l,0,n,i,a,o,s,1),p=V(t,W,F,L,p,3));let d=c;for(let e=0;e<E.length;e++)r([t.num,d],E[e])&&(D[e].splice(0,0,W),O=!0);O||(D.push([W]),E.push([e.V_1,e.b_1])),O=!1}else if(-1===e.V_1&&-1===e.b_1)g.log("unexpected square array",g.WARNING);else if(e.V_1===t.num&&1===Math.abs(e.b_1-c)){t.num%2==1&&W++,F=c,t.num%2==0&&(R=I(R,t,F,L,l,0,n,i,a,o,s,1),p=V(t,W,F,L,p,3));for(let e=0;e<E.length;e++){let s=c;r([t.num,s],E[e])&&(D[e].push(W),O=!0)}O||(D.push([W]),E.push([e.V_0,e.b_0])),O=!1}else g.log("unexpected square array",g.WARNING);c++}M++}else g.log(`No scaffold strand found in virtual helix n. ${t.num}: staples-only virtual helices are not supported`,g.WARNING)}let U,H=[j,D],B=[];for(let t=0;t<2;t++)for(const e of H[t])B.push(...e);for(let t=0;t<R._strands.length;t++)B.includes(t)||(z.add_strand(R._strands[t]),f.add_strand(t,p));for(let t=0;t<2;t++){const e=H[t];let n=!1;U=!1;for(const t of e){let e=R._strands[t[0]],s=R._strands[t[1]],n=e._nucleotides.slice(-1)[0].distance(s._nucleotides[0],!1),o=Math.sqrt(n.dot(n));(o>1.0018||o<.5525)&&g.log(`The backbone-backbone distance across joints is ${o}: it will have to be relaxed with preliminary simulations`,g.WARNING)}let o=[];for(;!n;){U=!1;for(let t=0;t<e.length&&!U;t++)for(let s=0;s<e.length&&!U;s++)if(e[t][0]===e[s].slice(-1)[0]){if(t!=s){e[s].push(...e[t].slice(1)),e.splice(t,1),U=!0;break}o.includes(t)||o.push(t)}U||(n=!0)}for(let t=0;t<e.length;t++){const n=e[t];let i,a=R._strands[n[0]];if(o.includes(t)){for(const t of s(1,n.length-1))a=a.append(R._strands[n[t]]);a.make_circular(!0)}else for(const t of s(1,n.length))a=a.append(R._strands[n[t]]);z.add_strand(a),i=a._circular?s(n.length-2):s(n.length-1);for(const t of i)f.add_strand(n[t],p,!0);f.add_strand(n[i[i.length-1]+1],p,!1)}}let Q=new y(z._box);for(const t of z._strands){let e=t._nucleotides.map((t=>t));e.reverse();let s=new b;for(const t of e)s.add_nucleotide(new m(t.cm_pos,t._a1,t._a3.clone().negate(),t._base));t._circular&&s.make_circular(),Q.add_strand(s)}let J=new N,Y=s(Q._N_strands),K=0;for(let t=0;t<Q._strands.length;t++){const e=Q._strands[t];Y[t]=K,K+=e._nucleotides.length}let X=new Map;for(const[t,e]of f._scaf.keys()){let[s,n]=f._scaf.get([t,e]),o=[];for(const i of n){const n=Q._strands[s]._nucleotides.length-1-(i-Y[s])+Y[s];o.push(n),X.set(n,[t,e])}J.add_scaf(t,e,s,o)}for(const[t,e]of f._stap.keys()){let[s,n]=f._stap.get([t,e]),o=[];for(const i of n){const n=Q._strands[s]._nucleotides.length-1-(i-Y[s])+Y[s];o.push(n),X.set(n,[t,e])}J.add_stap(t,e,s,o)}if(0===Q.N)return void g.log("The generated configuration is empty: this might be due to this conversion module not supporting virtual helices containing no scaffold strands.",g.CRITICAL);let Z=new x;for(const t of w.vhelices)for(const[e,s]of t.stap_colors)Z.set([t.num,e],s);let tt=new x;for(const[t,e]of X.entries())tt.has(e)||tt.set(e,[]),tt.get(e).push(t);let et=new Map;for(const t of Q._strands)for(const e of t._nucleotides)et.set(e.index,e);let st=[];for(const t of tt.values())for(const e of t)try{st.push(et.get(e).strand)}catch(t){console.log(`Could not find nucId ${e} strand`)}let nt=(ot=st,it={},ot.forEach((function(t){it[t]=(it[t]||0)+1})),Object.keys(it).reduce((function(t,e,s){return!s||it[e]>it[t[0]]?[e]:(it[e]===it[t[0]]&&t.push(e),t)}),[]))[0];var ot,it;for(const t of Q._strands)for(const e of t._nucleotides)if(X.has(e.index)){let[t,s]=X.get(e.index),n=tt.get([t,s]);n.length>1&&(e.pair=et.get(n.filter((t=>t!=e.index))[0]));let o=tt.get([t,s]).filter((t=>et.get(t).strand!=nt));if(o.length>0){let n=et.get(o[0]);e===n?Z.has([t,s])&&(e.color=Z.get([t,s])):e.color=3633362}}for(const t of Q._strands)for(const e of t._nucleotides)if(void 0!==e.color){for(const s of t._nucleotides)s.color=e.color;break}Q.calc_clusters();let at,rt=Q._strands[nt];l&&(rt.N>l.length?g.log(`Provided scaffold sequence is ${l.length}nt but needs to be at least ${rt.N} to cover the scaffold. `):(g.log("Applying custom sequence"),at=Array.from(l).map((t=>u[t])))),void 0===at&&(g.log("Applying random sequence"),at=i(0,4,rt.N));for(let t=0;t<rt.N;t++){let e=rt._nucleotides[t];e._base=at[rt.N-t-1],e.pair&&(e.pair._base=3-e._base)}for(let t=0;t<Q._strands.length;t++)if(t!==nt){const e=Q._strands[t];for(let t=0;t<e.N;t++){let s=e._nucleotides[t];s.pair||(s._base=u[a(d,!1)])}}return Q}(n[0],c.grid,c.sequence,c.side,c.default_val);break;case"rpoly":d=function(e,s){let n=[],o=[],a=[],r=0;for(const t of e.split("\n"))t.startsWith("hb")?(n.splice(r,0,t.split(" ")),r+=1):t.startsWith("c")&&(t.includes("f3")?a.push([parseInt(t.match(/c helix_(.+?) /)[1]),parseInt(t.match(/\' helix_(.+?) /)[1])]):o.push([parseInt(t.match(/c helix_(.+?) /)[1]),parseInt(t.match(/\' helix_(.+?) /)[1])]));let l=new w,c=new y(new t.Vector3(100,100,100)),d=new y(new t.Vector3(100,100,100)),h=0;for(let e=0;e<n.length;e++){const s=n[e];let o=new t.Vector3(parseFloat(s[3]),parseFloat(s[4]),parseFloat(s[5])).divideScalar(.84),i=parseInt(s[2]),a=new t.Quaternion(parseFloat(s[6]),parseFloat(s[7]),parseFloat(s[8]),parseFloat(s[9])),r=new t.Vector3(0,0,1).applyQuaternion(a),u=new t.Vector3(.65,-.76,0).applyQuaternion(a),_=G(o,r,i);for(const t of _.toArray())t>h&&(h=t);let p=l.generate_or_sq(i,_,r,u);for(const t of[0,1])for(const s of p[t]._nucleotides)s.cluster=e+1;let[f,g]=p[1].cut_in_two(!1);c.add_strand(f),c.add_strand(g),d.add_strand(p[0])}let _=new y(new t.Vector3(3*h,3*h,3*h));for(const t of o){let e=2*t[0]-1,s=2*t[1]-2,n=c._strands[e];n=n.append(c._strands[s]),_.add_strand(n)}let p,f=d._strands[0];for(const t of a.slice(0,-1)){let e=t[1]-1,s=d._strands[e];f=f.append(s)}s&&(f.N>s.length?g.log(`Provided scaffold sequence is ${s.length}nt but needs to be at least ${f.N} to cover the scaffold. `):(g.log("Applying custom sequence"),p=Array.from(s).map((t=>u[t])))),void 0===p&&(g.log("Applying random sequence"),p=i(0,4,f.N)),f._nucleotides.forEach(((t,e)=>{t._base=p[f.N-e-1],t.pair&&(t.pair._base=3-t._base)})),f.make_circular(),_.add_strand(f);let m=0,b=0;for(const t of _._strands)t.index=b++,t._nucleotides.forEach(((e,s)=>{e.index=m++,0===s?t._first=e.index:s==t.N-1&&(t._last=e.index)}));return _}(n[0],c.sequence);break;case"tiamat":d=function(e,s,n=!0,o="R"){let i;if(1===s)i=n?1.2:1.6;else{if(2!==s)throw`tiamat_version should be either '1' or '2' (got '${s}' instead)`;i=1}const a=function(e,s=!0){let n=new Map(e.map((t=>[t.id,t])));e.forEach((t=>{t.set_base_config(n)}));let o=1;for(const t of e)for(const e of t.cm_pos.toArray())Math.abs(e)>o/2&&(o=2*Math.abs(e));o*=1.5,o=Math.round(o);let i=new y(new t.Vector3(o,o,o));i.isDNA=s;let a=new Set,r=e.filter((t=>null===t.obj.down));for(const t of r){let e=new b,s=t;for(;void 0!==s;){let t=new m(s.cm_pos,s.a1,s.a3,s.val);s.nuc=t,e.add_nucleotide(t),a.add(s.id),s=s.getNeighbor(n,"up")}i.add_strand(e)}let l=function(t,e,s){let n=t.filter((t=>!s.has(t.id))),o=[];for(;n.length>0;){let t=new b,s=new Set,i=n[0];for(;!s.has(i.id);){let n=new m(i.cm_pos,i.a1,i.a3,i.val);i.nuc=n,t.add_nucleotide(n),s.add(i.id),i=i.getNeighbor(e,"up")}o.push(t),n=n.filter((t=>!s.has(t.id)))}return o}(e,n,a);return i.add_strands(l),e.forEach((t=>{null!==t.obj.across&&(t.nuc.pair=n.get(t.obj.across).nuc,void 0===t.obj.type&&(t.nuc._base=3-t.nuc.pair._base))})),g.log("Added base pairs strands"),i.calc_clusters(),i}(JSON.parse(e).bases.map((t=>new R(t,n,i,o))),n);return a}(n[0],c.tiamat_version,c.isDNA,c.default_val);break;case"pdb":d=function(e,s,n){let o,i,a,r=[],l=[];for(let t of e.split("\n")){t=t.trim();let e=new D(t);if(t.startsWith("ATOM"))""!==i&&(e.chain_id!==i&&0!==l.length?(g.log(`WARNING: a TER statement separating different strands (${e.chain_id} and ${i}) is missing`),r.push(l),l=[]):e.chain_id===i&&0===l.length&&g.log(`WARNING: a TER statement separates strands having the same chain id (${e.chain_id})`)),""!==e.alternate&&("A"!==e.alternate&&"1"!==e.alternate||g.log(`Alternate location for atom '${e.name}' of residue '${e.residue}' encountered, using the line marked with the '${e.alternate}' character.`)),e.residue_idx!==o&&(a=new j(e.residue,e.residue_idx),s?l.push(a):l.splice(0,0,a),o=e.residue_idx),a.add_atom(e),i=e.chain_id;else if(t.startsWith("MODEL")){if(!n){let e=t.split(" ")[1];g.log(`MODEL line detected: using the first MODEL encountered (${e})`)}}else if(t.startsWith("ENDMDL")){if(!n)break;l.length>0&&(r.push(l),l=[])}else(t.startsWith("TER")||"END"===t&&0===r.length&&l.length>0)&&(r.push(l),l=[])}l.length>0&&r.push(l);let c=new t.Vector3(1e6,1e6,1e6),d=new t.Vector3(-1e6,-1e6,-1e6);for(const t of[].concat(...r)){let e=t.get_com();for(let t=0;t<3;t++)e.getComponent(t)<c.getComponent(t)?c.setComponent(t,e.getComponent(t)):e.getComponent(t)>d.getComponent(t)&&d.setComponent(t,e.getComponent(t))}let h=2*Math.max(...d.clone().sub(c).toArray())*W;h=Math.ceil(h);let u=new t.Vector3(h,h,h);g.log(`Using a box of size ${h} in oxDNA units (twice as big as the PDB bounding box size)`);let _=new y(u);for(const t of r){let e=new b;for(const s of t){s.compute_as();let t=s.get_com().clone().multiplyScalar(W),n=new m(t,s.a1,s.a3,s.base[0]);e.add_nucleotide(n)}_.add_strand(e)}return _}(n[0],c.strand_dir,c.models_as_strands);break;default:return void console.log("Unknown input format: "+o)}switch(l){case"oxview":return d.print_oxview_output();case"oxdna":return d.print_lorenzo_output();default:console.log("Unknown output format: "+o)}}D.serial_atom=1})(),o})()}));